@page "/settings"
@using Microsoft.AspNetCore.Components.Authorization
@using AzDoBoards.Client
@using AzDoBoards.Data.Abstractions
@using AzDoBoards.Utility
@using MudBlazor
@using System.Text.Json
@inject ISettingsRepository SettingsRepository
@inject IServiceProvider ServiceProvider
@inject ISnackbar Snackbar
@inject ILogger<Settings> Logger

<PageTitle>Settings</PageTitle>

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4">
    <MudText Typo="Typo.h4" GutterBottom="true">Application Settings</MudText>

    @if (!string.IsNullOrEmpty(StatusMessage))
    {
        <MudAlert Severity="Severity.Info" Class="mb-4">@StatusMessage</MudAlert>
    }

    <MudGrid>
        <!-- Process Configuration (Consolidated with Project) -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardContent>
                    <MudText Typo="Typo.h6" GutterBottom="true">Process Configuration</MudText>

                    @if (isLoadingProcesses)
                    {
                        <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                        <MudText Typo="Typo.body2" Class="ml-2">Loading processes...</MudText>
                    }
                    else if (availableProcesses?.Any() == true)
                    {
                        <MudSelect T="string" @bind-Value="selectedProcessId" @bind-Value:after="OnProcessSelectionChanged" Label="Selected Process" Placeholder="Choose a process" Class="mb-3">
                            @foreach (var process in availableProcesses.OrderBy(p => p.Name))
                            {
                                <MudSelectItem T="string" Value="@process.Id.ToString()">
                                    @process.Name (@(process.IsSystemProcess ? "System" : process.ParentProcessName))
                                </MudSelectItem>
                            }
                        </MudSelect>

                        @if (isLoadingProjects)
                        {
                            <MudStack Row AlignItems="AlignItems.Center" Class="mb-3">
                                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                                <MudText Typo="Typo.body2" Class="ml-2">Loading projects...</MudText>
                            </MudStack>
                        }
                        else if (availableProjects?.Any() == true)
                        {
                            <MudSelect T="string" @bind-Value="selectedProjectId" @bind-Value:after="OnProjectSelectionChanged" Label="Selected Project" Placeholder="Choose a project" Class="mb-3">
                                @foreach (var project in availableProjects.OrderBy(p => p.Name))
                                {
                                    <MudSelectItem T="string" Value="@project.Id.ToString()">
                                        @project.Name
                                    </MudSelectItem>
                                }
                            </MudSelect>
                        }
                        else if (!string.IsNullOrEmpty(selectedProcessId))
                        {
                            <MudAlert Severity="Severity.Warning" Class="mb-3">No projects available for the selected process.</MudAlert>
                        }

                        @if (isLoadingWorkItems)
                        {
                            <MudStack Row AlignItems="AlignItems.Center" Class="mb-3">
                                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                                <MudText Typo="Typo.body2" Class="ml-2">Loading work items...</MudText>
                            </MudStack>
                        }

                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveDefaultConfigurationAsync" Class="mr-2" Disabled="!AllowDefaultConfigurationSave">
                            Set as Default
                        </MudButton>

                        @if (!AllowDefaultConfigurationSave && (!string.IsNullOrEmpty(selectedProcessId) || !string.IsNullOrEmpty(selectedProjectId)))
                        {
                            <MudAlert Severity="Severity.Info" Class="mt-3">
                                Select both a process and project to set as default configuration.
                            </MudAlert>
                        }
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Warning">No processes available. Please check your connection.</MudAlert>
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>

        <!-- Work Item Hierarchy Configuration (Full Interface) -->
        @if (!string.IsNullOrEmpty(selectedProcessId) && availableWorkItemTypes?.Any() == true)
        {
            <MudItem xs="12">
                <MudCard>
                    <MudCardContent>
                        <MudText Typo="Typo.h6" Class="mb-3">Work Item Hierarchy Configuration - @GetProcessName(selectedProcessId)</MudText>

                        @if (availableWorkItemTypes?.Any() == true)
                        {
                            <!-- Single Drop Container for all items -->
                            <MudDropContainer T="AzDoBoards.Client.WorkItemTypeInfo" Items="@availableWorkItemTypes" ItemsSelector="@GetItemsForDropzone" ItemDropped="OnItemDropped" Class="hierarchy-drop-container">
                                <ChildContent>
                                    <MudGrid>
                                        <!-- Unassigned Work Item Types -->
                                        <MudItem xs="12" md="4">
                                            <MudPaper Class="pa-4 unassigned-panel" Style="min-height: 500px;">
                                                <MudText Typo="Typo.subtitle1" GutterBottom="true">
                                                    <MudIcon Icon="Icons.Material.Filled.Inventory" Class="mr-2" />
                                                    Unassigned Work Items (@(unassignedWorkItems?.Count ?? 0))
                                                </MudText>

                                                <MudDropZone T="AzDoBoards.Client.WorkItemTypeInfo" Identifier="unassigned" Class="pa-2 drop-zone-content drop-zone-unassigned">
                                                    @if (unassignedWorkItems?.Any() == false)
                                                    {
                                                        <MudAlert Severity="Severity.Success">
                                                            <MudIcon Icon="Icons.Material.Filled.CheckCircle" Class="mr-2" />
                                                            All work item types are assigned to hierarchy
                                                        </MudAlert>
                                                    }
                                                </MudDropZone>
                                            </MudPaper>
                                        </MudItem>

                                        <!-- Hierarchy Builder -->
                                        <MudItem xs="12" md="8">
                                            <MudPaper Class="pa-4 hierarchy-panel" Style="min-height: 500px;">
                                                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-3">
                                                    <MudText Typo="Typo.subtitle1">
                                                        <MudIcon Icon="Icons.Material.Filled.AccountTree" Class="mr-2" />
                                                        Work Item Hierarchy (@workItemHierarchy.Count levels)
                                                    </MudText>
                                                    <MudStack Row>
                                                        <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="SaveHierarchyAsync" Disabled="!hasHierarchyChanges">
                                                            Save Hierarchy
                                                        </MudButton>
                                                        <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" OnClick="ClearHierarchy">
                                                            Clear All
                                                        </MudButton>
                                                    </MudStack>
                                                </MudStack>

                                                @if (workItemHierarchy?.Any() == true)
                                                {
                                                    <MudStack>
                                                        @for (int i = 0; i < workItemHierarchy.Count; i++)
                                                        {
                                                            var level = i;
                                                            var levelItems = workItemHierarchy[level];

                                                            <MudPaper Class="level-container" Style="@($"border-left: 4px solid {WorkItemHelper.GetLevelColor(level)}; margin-bottom: 8px;")">
                                                                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="level-header">
                                                                    <MudText Typo="Typo.subtitle2" Class="level-title">
                                                                        Level @(level + 1) (@levelItems.Count items)
                                                                    </MudText>
                                                                    <MudStack Row Spacing="1">
                                                                        <MudTooltip Text="Move level up">
                                                                            <MudIconButton Icon="@Icons.Material.Filled.MoveUp" Size="Size.Small" OnClick="@(() => MoveLevelUp(level))" Disabled="level == 0" Variant="@(level == 0 ? Variant.Outlined : Variant.Filled)" Color="@(level == 0 ? Color.Default : Color.Info)" />
                                                                        </MudTooltip>
                                                                        <MudTooltip Text="Move level down">
                                                                            <MudIconButton Icon="@Icons.Material.Filled.MoveDown" Size="Size.Small" OnClick="@(() => MoveLevelDown(level))" Disabled="level == workItemHierarchy.Count - 1" Variant="@(level == workItemHierarchy.Count - 1 ? Variant.Outlined : Variant.Filled)" Color="@(level == workItemHierarchy.Count - 1 ? Color.Default : Color.Info)" />
                                                                        </MudTooltip>
                                                                        <MudTooltip Text="Insert level above">
                                                                            <MudIconButton Icon="@IconSvg.IconAddRowAbove" Size="Size.Small" OnClick="@(() => AddLevelAbove(level))" Variant="Variant.Filled" Color="Color.Tertiary" />
                                                                        </MudTooltip>
                                                                        <MudTooltip Text="Insert level below">
                                                                            <MudIconButton Icon="@IconSvg.IconAddRowBelow" Size="Size.Small" OnClick="@(() => AddLevelBelow(level))" Variant="Variant.Filled" Color="Color.Tertiary" />
                                                                        </MudTooltip>
                                                                        @if (workItemHierarchy.Count > 1)
                                                                        {
                                                                            <MudTooltip Text="Remove level">
                                                                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" OnClick="@(() => RemoveLevel(level))" Variant="Variant.Filled" Color="Color.Error" />
                                                                            </MudTooltip>
                                                                        }
                                                                    </MudStack>
                                                                </MudStack>

                                                                <MudDropZone T="AzDoBoards.Client.WorkItemTypeInfo" Identifier="@($"level-{level}")" Class="level-drop-zone">
                                                                    @if (!levelItems.Any())
                                                                    {
                                                                        <MudText Typo="Typo.body2" Class="empty-level-text">
                                                                            Drop work items here or click items from the left panel
                                                                        </MudText>
                                                                    }
                                                                </MudDropZone>
                                                            </MudPaper>
                                                        }
                                                    </MudStack>
                                                }
                                                else
                                                {
                                                    <MudAlert Severity="Severity.Info" Class="getting-started-alert">
                                                        <MudStack>
                                                            <MudText>
                                                                <MudIcon Icon="Icons.Material.Filled.Info" Class="mr-2" />
                                                                Hierarchy will be created automatically when you assign work items.
                                                            </MudText>
                                                            <MudText Typo="Typo.body2" Class="mt-2">
                                                                Click on work items from the left panel to get started.
                                                            </MudText>
                                                        </MudStack>
                                                    </MudAlert>
                                                }
                                            </MudPaper>
                                        </MudItem>
                                    </MudGrid>
                                </ChildContent>
                                <ItemRenderer>
                                    @{
                                        var level = GetLevelForItem(context);
                                        var isInHierarchy = level >= 0;
                                    }
                                    <div class="draggable-item-wrapper @(isInHierarchy ? "hierarchy-chip" : "clickable-chip")" style="@GetWorkItemChipStyle(context, isInHierarchy)">
                                        <div class="d-flex align-center pa-2" @onclick="@(() => { if (!isInHierarchy) AddToHierarchy(context); })">
                                            <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(context.Name)" Size="Size.Small" Class="mr-2" />
                                            <MudText Class="flex-grow-1">@context.Name</MudText>
                                            @if (isInHierarchy)
                                            {
                                                <MudTooltip Text="Remove from hierarchy">
                                                    <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" OnClick="@(() => RemoveFromHierarchy(context, level))" Variant="Variant.Filled" Color="Color.Surface" Class="work-item-remove-button" />
                                                </MudTooltip>
                                            }
                                            <MudIcon Icon="Icons.Material.Filled.DragIndicator" Class="drag-handle" />
                                        </div>
                                    </div>
                                </ItemRenderer>
                            </MudDropContainer>
                        }
                        else
                        {
                            <MudAlert Severity="Severity.Info">Please select a process first to configure work item hierarchy.</MudAlert>
                        }
                    </MudCardContent>
                </MudCard>
            </MudItem>
        }
    </MudGrid>
</MudContainer>

@code {
    private bool isLoadingProcesses = true;
    private bool isLoadingWorkItems = false;
    private bool isLoadingProjects = false;
    private bool hasHierarchyChanges = false;
    private string StatusMessage = string.Empty;
    private string savedProcessId = string.Empty;
    private string savedProjectId = string.Empty;

    private string selectedProcessId = string.Empty;
    private string selectedProjectId = string.Empty;
    private List<AzDoBoards.Client.ProcessInfo>? availableProcesses;
    private List<AzDoBoards.Client.ProjectInfo>? availableProjects;
    private List<AzDoBoards.Client.WorkItemTypeInfo>? availableWorkItemTypes;
    private List<AzDoBoards.Client.WorkItemTypeInfo>? unassignedWorkItems;
    private List<List<AzDoBoards.Client.WorkItemTypeInfo>> workItemHierarchy = new();

    private string hierarchyJson => JsonSerializer.Serialize(
        workItemHierarchy.Select(level => level.Select(wi => wi.Name).ToArray()).ToArray(),
        new JsonSerializerOptions { WriteIndented = true });

    // Updated logic: Both process and project must be selected, and at least one must be different from saved values
    private bool AllowDefaultConfigurationSave =>
        !string.IsNullOrEmpty(selectedProcessId) &&
        !string.IsNullOrEmpty(selectedProjectId) &&
        (selectedProcessId != savedProcessId || selectedProjectId != savedProjectId);

    protected override async Task OnInitializedAsync()
    {
        await LoadSettingsAsync();
        await LoadProcessesAsync();
    }

    private async Task LoadSettingsAsync()
    {
        try
        {
            // Load saved process setting
            savedProcessId = await SettingsRepository.GetOrCreateAsync("process", string.Empty);
            selectedProcessId = savedProcessId;

            if (!string.IsNullOrEmpty(selectedProcessId))
            {
                await LoadWorkItemTypesAsync();
                await LoadWorkItemHierarchyAsync();
                await LoadProjectSettingsAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading settings");
            Snackbar.Add("Error loading settings", Severity.Error);
        }
    }

    private async Task LoadProjectSettingsAsync()
    {
        try
        {
            // Load saved project setting for the current process
            var projectKey = $"project-{savedProcessId}";
            savedProjectId = await SettingsRepository.GetOrCreateAsync(projectKey, string.Empty);
            selectedProjectId = savedProjectId;

            // Load available projects
            await LoadProjectsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading project settings");
            Snackbar.Add("Error loading project settings", Severity.Error);
        }
    }

    private async Task LoadProcessesAsync()
    {
        try
        {
            isLoadingProcesses = true;
            StateHasChanged();

            var authProvider = ServiceProvider.GetRequiredService<AuthenticationStateProvider>();
            var authState = await authProvider.GetAuthenticationStateAsync();

            if (!authState.User.Identity?.IsAuthenticated ?? false)
            {
                StatusMessage = "Please authenticate to load processes.";
                return;
            }

            var processClient = ServiceProvider.GetRequiredService<AzDoBoards.Client.Process>();
            availableProcesses = await processClient.GetProcessesAsync();

            StatusMessage = $"Loaded {availableProcesses.Count} processes";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading processes");
            StatusMessage = $"Error loading processes: {ex.Message}";
        }
        finally
        {
            isLoadingProcesses = false;
            StateHasChanged();
        }
    }

    private async Task LoadProjectsAsync()
    {
        try
        {
            isLoadingProjects = true;
            // Always clear existing projects when loading starts
            availableProjects = null;
            StateHasChanged();

            var authProvider = ServiceProvider.GetRequiredService<AuthenticationStateProvider>();
            var authState = await authProvider.GetAuthenticationStateAsync();

            if (!authState.User.Identity?.IsAuthenticated ?? false)
            {
                StatusMessage = "Please authenticate to load projects.";
                return;
            }

            var projectsClient = ServiceProvider.GetRequiredService<AzDoBoards.Client.Projects>();

            // Filter projects by the currently selected process if available
            availableProjects = null;
            if (!string.IsNullOrEmpty(selectedProcessId) && Guid.TryParse(selectedProcessId, out var processId))
                availableProjects = await projectsClient.GetProjectInfoAsync(processId);

            // If no saved project ID, but we have projects available, select the first one
            if (string.IsNullOrEmpty(selectedProjectId) && availableProjects?.Any() == true)
                selectedProjectId = availableProjects[0].Id.ToString();

            StatusMessage = $"Loaded {availableProjects?.Count ?? 0} projects for the selected process";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading projects");
            StatusMessage = $"Error loading projects: {ex.Message}";
            availableProjects = null; // Ensure projects are cleared on error
        }
        finally
        {
            isLoadingProjects = false;
            StateHasChanged();
        }
    }

    private async Task OnProcessSelectionChanged()
    {
        if (!string.IsNullOrEmpty(selectedProcessId))
        {
            // Clear existing data
            availableWorkItemTypes = null;
            workItemHierarchy.Clear();
            unassignedWorkItems = null;
            hasHierarchyChanges = false;

            // IMPORTANT: Clear projects and project selection when process changes
            availableProjects = null;
            selectedProjectId = string.Empty;

            await LoadWorkItemTypesAsync();
            await LoadWorkItemHierarchyAsync();

            // Load projects for the newly selected process
            await LoadProjectsAsync();

            StateHasChanged();
        }
    }

    private void OnProjectSelectionChanged()
    {
        StateHasChanged(); // Trigger UI update for button state
    }

    private async Task SaveDefaultConfigurationAsync()
    {
        try
        {
            // Validate that both process and project are selected
            if (string.IsNullOrEmpty(selectedProcessId) || string.IsNullOrEmpty(selectedProjectId))
            {
                Snackbar.Add("Both process and project must be selected", Severity.Warning);
                return;
            }

            // Get the selected process and project names for notes
            var selectedProcess = availableProcesses?.FirstOrDefault(p => p.Id.ToString() == selectedProcessId);
            var selectedProject = availableProjects?.FirstOrDefault(p => p.Id.ToString() == selectedProjectId);
            var processName = selectedProcess?.Name ?? "Unknown Process";
            var projectName = selectedProject?.Name ?? "Unknown Project";

            // Save process setting
            await SettingsRepository.SetAsync("process", selectedProcessId, $"Process: {processName}");
            savedProcessId = selectedProcessId;

            // Save project setting
            var projectKey = $"project-{savedProcessId}";
            await SettingsRepository.SetAsync(projectKey, selectedProjectId, $"Process: {processName}, Project: {projectName}");
            savedProjectId = selectedProjectId;

            Snackbar.Add($"Default configuration saved: {processName} / {projectName}", Severity.Success);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving default configuration");
            Snackbar.Add("Error saving default configuration", Severity.Error);
        }
    }

    private string GetProcessName(string processId)
    {
        if (string.IsNullOrEmpty(processId)) return "Unknown Process";
        var process = availableProcesses?.FirstOrDefault(p => p.Id.ToString() == processId);
        return process?.Name ?? "Unknown Process";
    }

    private async Task LoadWorkItemTypesAsync()
    {
        if (string.IsNullOrEmpty(selectedProcessId) || !Guid.TryParse(selectedProcessId, out var processId))
            return;

        try
        {
            isLoadingWorkItems = true;
            StateHasChanged();

            var processClient = ServiceProvider.GetRequiredService<AzDoBoards.Client.Process>();
            availableWorkItemTypes = await processClient.GetWorkItemTypesForProcessAsync(processId);

            await LoadWorkItemHierarchyAsync();
            UpdateUnassignedWorkItems();

            StatusMessage = $"Loaded {availableWorkItemTypes.Count} work item types";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading work item types");
            StatusMessage = $"Error loading work item types: {ex.Message}";
        }
        finally
        {
            isLoadingWorkItems = false;
            StateHasChanged();
        }
    }

    private async Task LoadWorkItemHierarchyAsync()
    {
        try
        {
            var hierarchyKey = $"work-item-hierarchy-{selectedProcessId}";
            var hierarchyJson = await SettingsRepository.GetOrCreateAsync(hierarchyKey, "[]");

            if (!string.IsNullOrEmpty(hierarchyJson) && hierarchyJson != "[]")
            {
                var hierarchyData = JsonSerializer.Deserialize<string[][]>(hierarchyJson);
                if (hierarchyData != null && availableWorkItemTypes != null)
                {
                    workItemHierarchy.Clear();
                    foreach (var level in hierarchyData)
                    {
                        var levelItems = new List<AzDoBoards.Client.WorkItemTypeInfo>();
                        foreach (var workItemName in level)
                        {
                            var workItem = availableWorkItemTypes.FirstOrDefault(w => w.Name == workItemName);
                            if (workItem != null)
                            {
                                levelItems.Add(workItem);
                            }
                        }
                        if (levelItems.Any())
                        {
                            workItemHierarchy.Add(levelItems);
                        }
                    }
                }
            }

            UpdateUnassignedWorkItems();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading work item hierarchy");
        }
    }

    private async Task SaveHierarchyAsync()
    {
        try
        {
            // Get the selected process name for notes
            var selectedProcess = availableProcesses?.FirstOrDefault(p => p.Id.ToString() == selectedProcessId);
            var processName = selectedProcess?.Name ?? "Unknown Process";

            var hierarchyKey = $"work-item-hierarchy-{selectedProcessId}";
            var hierarchyData = workItemHierarchy.Select(level => level.Select(wi => wi.Name).ToArray()).ToArray();
            var hierarchyJson = JsonSerializer.Serialize(hierarchyData);

            await SettingsRepository.SetAsync(hierarchyKey, hierarchyJson, $"Process: {processName}");
            hasHierarchyChanges = false;

            Snackbar.Add("Work item hierarchy saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving work item hierarchy");
            Snackbar.Add("Error saving work item hierarchy", Severity.Error);
        }
    }

    private void UpdateUnassignedWorkItems()
    {
        if (availableWorkItemTypes == null)
        {
            unassignedWorkItems = null;
            return;
        }

        var assignedWorkItems = workItemHierarchy.SelectMany(level => level).ToHashSet();
        unassignedWorkItems = availableWorkItemTypes.Where(wi => !assignedWorkItems.Contains(wi)).ToList();
        
        // Automatically create Level 1 if there are unassigned work items but no hierarchy levels
        if (unassignedWorkItems.Any() && workItemHierarchy.Count == 0)
        {
            workItemHierarchy.Add(new List<AzDoBoards.Client.WorkItemTypeInfo>());
            hasHierarchyChanges = true;
        }
    }

    private void AddToHierarchy(AzDoBoards.Client.WorkItemTypeInfo workItem)
    {
        // Automatically create first level if hierarchy is empty
        if (workItemHierarchy.Count == 0)
            workItemHierarchy.Add(new List<AzDoBoards.Client.WorkItemTypeInfo>());

        workItemHierarchy[0].Add(workItem);
        UpdateUnassignedWorkItems();
        hasHierarchyChanges = true;
        StateHasChanged();
    }

    private void RemoveFromHierarchy(AzDoBoards.Client.WorkItemTypeInfo workItem, int level)
    {
        if (level < workItemHierarchy.Count)
        {
            workItemHierarchy[level].Remove(workItem);

            // Remove empty levels
            if (!workItemHierarchy[level].Any())
                workItemHierarchy.RemoveAt(level);

            UpdateUnassignedWorkItems();
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private int GetLevelForItem(AzDoBoards.Client.WorkItemTypeInfo item)
    {
        for (int i = 0; i < workItemHierarchy.Count; i++)
        {
            if (workItemHierarchy[i].Contains(item))
                return i;
        }
        return -1; // Item is unassigned
    }

    private void AddLevelAbove(int level)
    {
        if (level >= 0 && level <= workItemHierarchy.Count)
        {
            workItemHierarchy.Insert(level, new List<AzDoBoards.Client.WorkItemTypeInfo>());
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void AddLevelBelow(int level)
    {
        if (level >= 0 && level < workItemHierarchy.Count)
        {
            workItemHierarchy.Insert(level + 1, new List<AzDoBoards.Client.WorkItemTypeInfo>());
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void RemoveLevel(int level)
    {
        if (level < workItemHierarchy.Count && workItemHierarchy.Count > 1)
        {
            // Move items back to unassigned
            workItemHierarchy.RemoveAt(level);
            UpdateUnassignedWorkItems();
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void MoveLevelUp(int level)
    {
        if (level > 0 && level < workItemHierarchy.Count)
        {
            var temp = workItemHierarchy[level];
            workItemHierarchy[level] = workItemHierarchy[level - 1];
            workItemHierarchy[level - 1] = temp;
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void MoveLevelDown(int level)
    {
        if (level >= 0 && level < workItemHierarchy.Count - 1)
        {
            var temp = workItemHierarchy[level];
            workItemHierarchy[level] = workItemHierarchy[level + 1];
            workItemHierarchy[level + 1] = temp;
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void ClearHierarchy()
    {
        workItemHierarchy.Clear();
        // Automatically create an empty level after clearing
        workItemHierarchy.Add(new List<AzDoBoards.Client.WorkItemTypeInfo>());
        UpdateUnassignedWorkItems();
        hasHierarchyChanges = true;
        StateHasChanged();
    }

    private void OnItemDropped(MudItemDropInfo<AzDoBoards.Client.WorkItemTypeInfo> dropItem)
    {
        if (dropItem.Item == null) return;

        // Remove from current location first
        foreach (var level in workItemHierarchy)
            level.Remove(dropItem.Item);

        // Handle drop to specific level
        if (dropItem.DropzoneIdentifier.StartsWith("level-"))
        {
            var targetLevel = int.Parse(dropItem.DropzoneIdentifier.Replace("level-", ""));

            // Ensure level exists
            while (workItemHierarchy.Count <= targetLevel)
                workItemHierarchy.Add(new List<AzDoBoards.Client.WorkItemTypeInfo>());

            workItemHierarchy[targetLevel].Add(dropItem.Item);
        }
        // If dropped to unassigned, it's already removed from hierarchy above

        UpdateUnassignedWorkItems();
        hasHierarchyChanges = true;
        StateHasChanged();
    }

    private bool GetItemsForDropzone(AzDoBoards.Client.WorkItemTypeInfo item, string dropzone)
    {
        if (dropzone == "unassigned")
            return unassignedWorkItems?.Contains(item) ?? false;

        if (dropzone.StartsWith("level-"))
        {
            var level = int.Parse(dropzone.Replace("level-", ""));
            return level < workItemHierarchy.Count && workItemHierarchy[level].Contains(item);
        }

        return false;
    }

    private string GetWorkItemChipStyle(AzDoBoards.Client.WorkItemTypeInfo workItem, bool inHierarchy)
    {
        var baseColor = !string.IsNullOrEmpty(workItem.Color) ? workItem.Color : "#1976d2";

        if (inHierarchy)
            return $"background-color: {baseColor}; color: white; margin: 4px; border: 2px solid rgba(255,255,255,0.3); box-shadow: 0 2px 4px rgba(0,0,0,0.2); border-radius: 8px; min-width: 150px; max-width: 200px;";
        else
            return $"background-color: {baseColor}; color: white; margin: 4px; opacity: 0.9; transition: all 0.2s ease-in-out; border-radius: 8px; min-width: 150px; max-width: 200px;";
    }
}