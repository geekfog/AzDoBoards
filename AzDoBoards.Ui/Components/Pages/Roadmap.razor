@page "/roadmap"
@using Microsoft.AspNetCore.Components.Authorization
@using AzDoBoards.Client.Models
@using AzDoBoards.Ui.Services
@using AzDoBoards.Utility
@using AzDoBoards.Models.Roadmap
@using MudBlazor
@inject IRoadmapService RoadmapService
@inject ISnackbar Snackbar
@inject ILogger<Roadmap> Logger
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Roadmap</PageTitle>

<h1>Roadmap</h1>

<MudContainer MaxWidth="MaxWidth.False" Class="roadmap-container">
    @if (isLoading)
    {
        <MudStack Row AlignItems="AlignItems.Center" Class="my-4">
            <MudProgressCircular Indeterminate="true" Size="Size.Small" />
            <MudText Typo="Typo.body2" Class="ml-2">Loading roadmap data...</MudText>
        </MudStack>
    }
    else if (!string.IsNullOrEmpty(errorMessage))
    {
        <MudAlert Severity="Severity.Error" Class="my-4">
            @errorMessage
            <MudButton Variant="Variant.Text" Color="Color.Primary" OnClick="RefreshDataAsync" Class="ml-2">
                Try Again
            </MudButton>
        </MudAlert>
    }
    else if (swimlanes?.Any() != true && unscheduledItems?.Any() != true)
    {
        <MudAlert Severity="Severity.Info" Class="my-4">
            <MudStack>
                <MudText>
                    <MudIcon Icon="@Icons.Material.Filled.Info" Class="mr-2" />
                    No roadmap items found
                </MudText>
                <MudText Typo="Typo.body2" Class="mt-2">
                    Make sure you have configured your work item hierarchy with Roadmap audience in Settings.
                </MudText>
                <MudButton Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Settings" Href="/settings" Class="mt-2 align-self-start">
                    Settings
                </MudButton>
            </MudStack>
        </MudAlert>
    }
    else
    {
        <div class="roadmap-layout">
            <MudPaper Class="@($"unscheduled-panel{(unscheduledPanelCollapsed ? " collapsed" : "")}")" Elevation="2">
                <div class="unscheduled-panel-header">
                    <div class="unscheduled-panel-title">
                        @if (!unscheduledPanelCollapsed)
                        {
                            @* <MudIcon Icon="@Icons.Material.Filled.Schedule" /> *@
                            <MudText Typo="Typo.h6">
                                Unscheduled Items (@(unscheduledItems?.Count ?? 0))
                            </MudText>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Style="font-weight: 600;">
                                Unscheduled Items (@(unscheduledItems?.Count ?? 0))
                            </MudText>
                        }
                    </div>
                    <MudIconButton 
                        Icon="@(unscheduledPanelCollapsed ? Icons.Material.Filled.ChevronRight : Icons.Material.Filled.ChevronLeft)" 
                        Size="Size.Small" 
                        OnClick="@(() => unscheduledPanelCollapsed = !unscheduledPanelCollapsed)"
                        Title="@(unscheduledPanelCollapsed ? "Expand" : "Collapse")" />
                </div>
                
                <div class="unscheduled-items-scroll" ondragover="event.preventDefault();" @ondrop="@(() => HandleUnscheduleDrop())">
                    @if (unscheduledItems?.Any() == true)
                    {
                        @foreach (var item in unscheduledItems)
                        {
                            <div class="unscheduled-work-item pa-2 mb-2" style="@GetUnscheduledItemStyle(item)" draggable="true" @ondragstart="@(() => OnDragStart(item.WorkItemId))" @ondragend="@OnDragEnd">
                                <MudStack Spacing="1">
                                    <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                        <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
                                            <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(item.WorkItemType)" Size="Size.Small" />
                                            <MudText Typo="Typo.caption" Style="font-weight: 600; color: white;">@item.WorkItemId</MudText>
                                        </MudStack>
                                        <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(async () => await OpenScheduleDialog(item.WorkItemId))" Style="color: white;" />
                                    </MudStack>
                                    <MudText Typo="Typo.body2" Style="font-weight: 500; color: white;">@item.Title</MudText>
                                    @if (!string.IsNullOrEmpty(item.ParentTitle))
                                    {
                                        <MudText Typo="Typo.caption" Style="color: rgba(255,255,255,0.8);">
                                            Parent: @item.ParentTitle
                                        </MudText>
                                    }
                                    @if (!string.IsNullOrEmpty(item.AssignedTo))
                                    {
                                        <MudText Typo="Typo.caption" Style="color: rgba(255,255,255,0.8);">
                                            <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" />
                                            @item.AssignedTo
                                        </MudText>
                                    }
                                </MudStack>
                            </div>
                        }
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Success" Class="ma-3">
                            All roadmap items are scheduled!
                        </MudAlert>
                    }
                </div>
            </MudPaper>

            <div class="timeline-panel">
                <MudPaper Class="timeline-header" Elevation="2">
                    <div class="timeline-header-row">
                        <div class="timeline-controls">
                            <MudStack Row AlignItems="AlignItems.Center" Spacing="2" Class="pa-2">
                                <MudButton OnClick="@(() => ChangeTimeUnit(TimeUnit.Week))" Color="Color.Primary" Size="Size.Small" Variant="@(config.TimeUnit == TimeUnit.Week ? Variant.Filled : Variant.Outlined)">
                                    Week
                                </MudButton>
                                <MudButton OnClick="@(() => ChangeTimeUnit(TimeUnit.Month))" Color="Color.Primary" Size="Size.Small" Variant="@(config.TimeUnit == TimeUnit.Month ? Variant.Filled : Variant.Outlined)">
                                    Month
                                </MudButton>
                                <MudButton OnClick="@(() => ChangeTimeUnit(TimeUnit.Quarter))" Color="Color.Primary" Size="Size.Small" Variant="@(config.TimeUnit == TimeUnit.Quarter ? Variant.Filled : Variant.Outlined)">
                                    Quarter
                                </MudButton>
                                <MudDatePicker Label="Start" Date="config.StartDate" DateChanged="@OnStartDateChanged" Variant="Variant.Outlined" Margin="Margin.Dense" Class="date-picker-compact" />
                                <MudDatePicker Label="End"   Date="config.EndDate"   DateChanged="@OnEndDateChanged"   Variant="Variant.Outlined" Margin="Margin.Dense" Class="date-picker-compact" />
                                <MudIconButton Icon="@Icons.Material.Filled.Refresh" Color="Color.Primary" OnClick="RefreshDataAsync" Size="Size.Small" />
                            </MudStack>
                        </div>
                    </div>
                </MudPaper>

                <div class="swimlanes-scroll">
                    <div class="timeline-header-content">
                        <div class="workitems-header">
                            <MudText Typo="Typo.subtitle2" Class="pa-2" Style="font-weight: 600;">Work Items</MudText>
                        </div>
                        <div class="timeline-dates" style="@GetTimelineContentWidthStyle()">
                            @foreach (var period in GetTimelinePeriods())
                            {
                                <div class="timeline-period" style="@GetPeriodStyle(period)">
                                    <MudStack Spacing="0" Class="pa-1">
                                        <MudText Typo="Typo.caption" Style="font-weight: 600; text-align: center;">@period.Label</MudText>
                                        @if (!string.IsNullOrEmpty(period.SubLabel))
                                        {
                                            <MudText Typo="Typo.caption" Style="font-size: 0.65rem; opacity: 0.8; text-align: center;">@period.SubLabel</MudText>
                                        }
                                    </MudStack>
                                </div>
                            }
                        </div>
                    </div>

                    <div class="swimlanes-content">
                        <div class="swimlane-labels">
                            @{
                                var swimLanesList = swimlanes ?? new List<SwimLane>();
                                foreach (var swimlane in swimLanesList)
                                {
                                    @RenderSwimLaneLabel(swimlane, 0)
                                }
                            }
                        </div>
                        <div class="timeline-items-container" style="@GetTimelineContentWidthStyle()" ondragover="event.preventDefault();" @ondrop="@HandleTimelineDrop"> 
                            @foreach (var swimlane in swimLanesList)
                            {
                                @RenderSwimLaneTimeline(swimlane, 0)
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
</MudContainer>

<MudDialog @bind-Visible="scheduleDialogVisible" Options="dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.Schedule" Class="mr-2" />
            Schedule Work Item
        </MudText>
    </TitleContent>
    <DialogContent>
        @if (selectedWorkItem != null)
        {
            <MudStack Spacing="3">
                <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                    <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(selectedWorkItem.WorkItemType)" Size="Size.Small" />
                    <MudText Typo="Typo.body1">@selectedWorkItemId - <span style="font-weight: 600;">@selectedWorkItem.Title</span></MudText>
                </MudStack>
                <MudDivider />
                <MudStack Row AlignItems="AlignItems.Center" Spacing="3">
                    <MudSelect T="string" Label="State" @bind-Value="selectedWorkItemState" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomLeft" Style="min-width: 150px; max-width: 200px;">
                        @foreach (var state in availableStates)
                        {
                            <MudSelectItem T="string" Value="@state">@state</MudSelectItem>
                        }
                    </MudSelect>
                    <MudDatePicker Label="Start Date" Date="scheduleStartDate" DateChanged="@((DateTime? d) => scheduleStartDate = d)" Clearable="true" />  @* Required="true" *@
                    <MudDatePicker Label="Target Date" Date="scheduleTargetDate" DateChanged="@((DateTime? d) => scheduleTargetDate = d)" Clearable="true" />
                </MudStack>
                @if (scheduleStartDate.HasValue && scheduleTargetDate.HasValue && scheduleStartDate.Value > scheduleTargetDate.Value)
                {
                    <MudAlert Severity="Severity.Warning">Start date cannot be after target date</MudAlert>
                }
            </MudStack>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseScheduleDialog">Cancel</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="SaveWorkItem" Disabled="@(scheduleStartDate.HasValue && scheduleTargetDate.HasValue && scheduleStartDate.Value > scheduleTargetDate.Value)">
            Save Schedule
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    private bool isLoading = true;
    private string errorMessage = string.Empty;
    private Config config = new();
    private List<SwimLane>? swimlanes;
    private List<UnscheduledWorkItem>? unscheduledItems;
    private List<WorkItem>? allWorkItems;
    private string currentProcessId = string.Empty;
    private string currentProjectId = string.Empty;

    // Drag and drop state
    private int? draggedWorkItemId;
    private DateTime? dropTargetDate;
    private bool wasResizeOrDragOperation = false;
    private DateTime lastResizeOrDragTime = DateTime.MinValue;

    // JavaScript interop
    private IJSObjectReference? jsModule;
    private DotNetObjectReference<Roadmap>? dotNetRef;
    private bool jsModuleInitialized = false;

    // Schedule dialog state
    private bool scheduleDialogVisible = false;
    private int selectedWorkItemId = 0;
    private WorkItem? selectedWorkItem;
    private DateTime? scheduleStartDate;
    private DateTime? scheduleTargetDate;
    private string? selectedWorkItemState;
    private List<string> availableStates = new();

    private DialogOptions dialogOptions = new() { MaxWidth = MaxWidth.Small, FullWidth = true };

    // Unscheduled panel collapse state
    private bool unscheduledPanelCollapsed = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadRoadmapDataAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Wait a bit for the DOM to settle
            await Task.Delay(100);
        }
        
        if (!isLoading && !jsModuleInitialized && (swimlanes?.Any() == true || unscheduledItems?.Any() == true))
        {
            await InitializeJavaScriptModule();
        }
    }

    private async Task InitializeJavaScriptModule()
    {
        try
        {
            Logger.LogInformation("Initializing JavaScript module for drag and drop");
            
            // Import the JavaScript module
            jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./Components/Pages/Roadmap.razor.js");

            Logger.LogInformation("JavaScript module imported successfully");

            dotNetRef = DotNetObjectReference.Create(this); // Create .NET reference for callbacks

            // Initialize the drag and drop system with aligned start date
            var pixelsPerDay = GetPixelsPerDay();
            var alignedStartDate = GetAlignedStartDate();
            
            Logger.LogInformation("Initializing drag system with dates: {StartDate} to {EndDate}, pixels per day: {PixelsPerDay}", 
                alignedStartDate, config.EndDate, pixelsPerDay);
            
            await jsModule.InvokeVoidAsync("initialize", 
                dotNetRef, 
                alignedStartDate.ToString("yyyy-MM-dd"), 
                config.EndDate.ToString("yyyy-MM-dd"), 
                pixelsPerDay);
            
            jsModuleInitialized = true;
            Logger.LogInformation("JavaScript module initialized successfully");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing JavaScript module");
            jsModuleInitialized = false;
        }
    }

    private async Task UpdateJavaScriptConfig()
    {
        if (jsModule != null && jsModuleInitialized)
        {
            try
            {
                var pixelsPerDay = GetPixelsPerDay();
                var alignedStartDate = GetAlignedStartDate();
                
                Logger.LogInformation("Updating JS config: {StartDate} to {EndDate}, pixels: {PixelsPerDay}", 
                    alignedStartDate, config.EndDate, pixelsPerDay);
                
                await jsModule.InvokeVoidAsync("updateConfig",
                    alignedStartDate.ToString("yyyy-MM-dd"),
                    config.EndDate.ToString("yyyy-MM-dd"),
                    pixelsPerDay);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error updating JavaScript config");
            }
        }
    }

    [JSInvokable]
    public void SetDropTargetDate(String dateString)
    {
        try
        {
            if (DateTime.TryParse(dateString, out var date))
            {
                dropTargetDate = date.Date; // Normalize to date only
                Logger.LogInformation("Drop target date set to: {Date}", dropTargetDate);
            }
            else
            {
                Logger.LogWarning("Failed to parse drop target date: {DateString}", dateString);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error setting drop target date");
        }
    }

    [JSInvokable]
    public async Task HandleResizeLeft(int workItemId, string newStartDateString)
    {
        try
        {
            if (!DateTime.TryParse(newStartDateString, out var newStartDate))
            {
                Logger.LogWarning("Failed to parse new start date: {DateString}", newStartDateString);
                return;
            }

            Logger.LogInformation("Resize left: WorkItem {WorkItemId}, new start date {StartDate}", workItemId, newStartDate);

            var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == workItemId);
            if (workItem == null)
            {
                Logger.LogWarning("Work item {WorkItemId} not found", workItemId);
                return;
            }

            var currentTargetDate = workItem.TargetDate;
            if (!currentTargetDate.HasValue)
            {
                Logger.LogWarning("Work item {WorkItemId} has no target date", workItemId);
                return;
            }

            // Validate that start date is not after target date
            if (newStartDate >= currentTargetDate.Value)
            {
                Logger.LogWarning("New start date {StartDate} is after target date {TargetDate}", newStartDate, currentTargetDate);
                Snackbar.Add("Start date cannot be after target date", Severity.Warning);
                await LoadRoadmapDataAsync();
                await ReinitializeJavaScriptModuleAsync();
                return;
            }

            var originalStartDate = workItem.Fields.TryGetValue("Microsoft.VSTS.Scheduling.StartDate", out var startDateObj) && startDateObj is DateTime sd
                ? (DateTime?)sd
                : null;

            // Update local state immediately for responsiveness
            workItem.Fields["Microsoft.VSTS.Scheduling.StartDate"] = newStartDate;
            UpdateTimelineItemStartDate(workItemId, newStartDate);
            StateHasChanged();

            // Update in Azure DevOps
            var success = await RoadmapService.UpdateWorkItemDatesAsync(workItemId, newStartDate, currentTargetDate.Value);

            if (success)
            {
                Logger.LogInformation("Successfully updated start date for work item {WorkItemId}", workItemId);
                Snackbar.Add($"Work item {workItemId} start date updated to {newStartDate:M/d/yyyy}", Severity.Success);
                
                // Mark that a resize operation occurred
                wasResizeOrDragOperation = true;
                lastResizeOrDragTime = DateTime.UtcNow;
            }
            else
            {
                Logger.LogError("Failed to update work item {WorkItemId}, reverting changes", workItemId);
                
                // Revert changes
                if (originalStartDate.HasValue)
                    workItem.Fields["Microsoft.VSTS.Scheduling.StartDate"] = originalStartDate.Value;
                else
                    workItem.Fields.Remove("Microsoft.VSTS.Scheduling.StartDate");
                
                UpdateTimelineItemStartDate(workItemId, originalStartDate);
                StateHasChanged();
                
                Snackbar.Add($"Failed to update work item {workItemId}", Severity.Error);
                await LoadRoadmapDataAsync();
                await ReinitializeJavaScriptModuleAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling resize left for work item {WorkItemId}", workItemId);
            Snackbar.Add($"Error updating work item: {ex.Message}", Severity.Error);
            await LoadRoadmapDataAsync();
            await ReinitializeJavaScriptModuleAsync();
        }
    }

    [JSInvokable]
    public async Task HandleResizeRight(int workItemId, string newTargetDateString)
    {
        try
        {
            if (!DateTime.TryParse(newTargetDateString, out var newTargetDate))
            {
                Logger.LogWarning("Failed to parse new target date: {DateString}", newTargetDateString);
                return;
            }

            Logger.LogInformation("Resize right: WorkItem {WorkItemId}, new target date {TargetDate}", workItemId, newTargetDate);

            var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == workItemId);
            if (workItem == null)
            {
                Logger.LogWarning("Work item {WorkItemId} not found", workItemId);
                return;
            }

            var currentStartDate = workItem.Fields.TryGetValue("Microsoft.VSTS.Scheduling.StartDate", out var startDateObj) && startDateObj is DateTime sd
                ? (DateTime?)sd
                : null;

            var originalTargetDate = workItem.TargetDate;

            // Validate that target date is not before start date (only if start date exists)
            if (currentStartDate.HasValue && newTargetDate <= currentStartDate.Value)
            {
                Logger.LogWarning("New target date {TargetDate} is before start date {StartDate}", newTargetDate, currentStartDate);
                Snackbar.Add("Target date cannot be before start date", Severity.Warning);
                await LoadRoadmapDataAsync();
                await ReinitializeJavaScriptModuleAsync();
                return;
            }

            // Update local state immediately for responsiveness - ONLY update target date
            workItem.TargetDate = newTargetDate;
            
            UpdateTimelineItemTargetDate(workItemId, newTargetDate);
            StateHasChanged();

            // Update in Azure DevOps - only update target date, keep existing start date
            var success = await RoadmapService.UpdateWorkItemDatesAsync(workItemId, currentStartDate, newTargetDate);

            if (success)
            {
                Logger.LogInformation("Successfully updated target date for work item {WorkItemId}", workItemId);
                var message = currentStartDate.HasValue
                    ? $"Work item {workItemId} updated: {currentStartDate.Value:M/d/yyyy} - {newTargetDate:M/d/yyyy}"
                    : $"Work item {workItemId} target date updated to {newTargetDate:M/d/yyyy}";
                Snackbar.Add(message, Severity.Success);
                
                // Mark that a resize operation occurred
                wasResizeOrDragOperation = true;
                lastResizeOrDragTime = DateTime.UtcNow;
            }
            else
            {
                Logger.LogError("Failed to update work item {WorkItemId}, reverting changes", workItemId);
                
                // Revert changes - restore original target date
                workItem.TargetDate = originalTargetDate;
                
                UpdateTimelineItemTargetDate(workItemId, originalTargetDate);
                StateHasChanged();
                
                Snackbar.Add($"Failed to update work item {workItemId}", Severity.Error);
                await LoadRoadmapDataAsync();
                await ReinitializeJavaScriptModuleAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling resize right for work item {WorkItemId}", workItemId);
            Snackbar.Add($"Error updating work item: {ex.Message}", Severity.Error);
            await LoadRoadmapDataAsync();
            await ReinitializeJavaScriptModuleAsync();
        }
    }

    private void UpdateTimelineItemStartDate(int workItemId, DateTime? newStartDate)
    {
        var swimlane = FindSwimlaneForWorkItem(workItemId, swimlanes);
        if (swimlane != null)
        {
            var timelineItem = swimlane.TimelineItems?.FirstOrDefault(ti => ti.WorkItemId == workItemId);
            if (timelineItem != null)
            {
                timelineItem.StartDate = newStartDate;
            }
        }
    }

    private void UpdateTimelineItemTargetDate(int workItemId, DateTime? newTargetDate)
    {
        var swimlane = FindSwimlaneForWorkItem(workItemId, swimlanes);
        if (swimlane != null)
        {
            var timelineItem = swimlane.TimelineItems?.FirstOrDefault(ti => ti.WorkItemId == workItemId);
            if (timelineItem != null)
            {
                timelineItem.TargetDate = newTargetDate;
            }
        }
    }

    private async Task LoadRoadmapDataAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = string.Empty;
            StateHasChanged();

            config = await RoadmapService.GetDefaultConfigurationAsync();
            (currentProcessId, currentProjectId) = await RoadmapService.GetConfigurationAsync();

            if (string.IsNullOrEmpty(currentProcessId) || string.IsNullOrEmpty(currentProjectId))
            {
                errorMessage = "Please configure your process and project in Settings first.";
                return;
            }

            allWorkItems = await RoadmapService.LoadRoadmapWorkItemsAsync(currentProjectId, currentProcessId);

            if (allWorkItems?.Count > 0)
            {
                swimlanes = await RoadmapService.BuildRoadmapSwimlanesAsync(allWorkItems, currentProcessId);
                unscheduledItems = await RoadmapService.GetUnscheduledWorkItemsAsync(allWorkItems, currentProcessId);
            }
            else
            {
                swimlanes = new List<SwimLane>();
                unscheduledItems = new List<UnscheduledWorkItem>();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading roadmap data");
            errorMessage = $"Error loading roadmap: {ex.Message}";
            Snackbar.Add(errorMessage, Severity.Error);
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task RefreshDataAsync()
    {
        await LoadRoadmapDataAsync();
        await ReinitializeJavaScriptModuleAsync();
        Snackbar.Add("Roadmap refreshed", Severity.Success);
    }

    private async Task ChangeTimeUnit(TimeUnit newUnit)
    {
        config.TimeUnit = newUnit;
        await RoadmapService.SaveConfigurationAsync(config);
        await UpdateJavaScriptConfig();
        StateHasChanged();
    }

    private async Task OnStartDateChanged(DateTime? newDate)
    {
        if (!newDate.HasValue) return;

        config.StartDate = newDate.Value;
        await RoadmapService.SaveConfigurationAsync(config);
        await UpdateJavaScriptConfig();
        StateHasChanged();
    }

    private async Task OnEndDateChanged(DateTime? newDate)
    {
        if (!newDate.HasValue) return;

        config.EndDate = newDate.Value;
        await RoadmapService.SaveConfigurationAsync(config);
        await UpdateJavaScriptConfig();
        StateHasChanged();
    }

    /// <summary>
    /// Reinitializes the JavaScript drag and drop module after DOM changes.
    /// Call this after any operation that reloads the roadmap data.
    /// </summary>
    private async Task ReinitializeJavaScriptModuleAsync()
    {
        if (jsModuleInitialized)
        {
            jsModuleInitialized = false;
            await Task.Delay(100); // Wait for DOM to update
            await InitializeJavaScriptModule();
        }
    }

    // Drag and Drop handlers
    private void OnDragStart(int workItemId)
    {
        draggedWorkItemId = workItemId;
        Logger.LogInformation("Drag started for work item {WorkItemId}", workItemId);
    }

    private void OnDragEnd()
    {
        Logger.LogInformation("Drag ended");
        draggedWorkItemId = null;
        dropTargetDate = null;
    }

    private async Task HandleTimelineDrop()
    {
        Logger.LogInformation("HandleTimelineDrop called. DraggedItemId: {ItemId}, DropTargetDate: {Date}", 
            draggedWorkItemId, dropTargetDate);
        
        if (!draggedWorkItemId.HasValue)
        {
            Logger.LogWarning("Drop called but no dragged work item ID");
            OnDragEnd();
            return;
        }

        if (!dropTargetDate.HasValue)
        {
            Logger.LogWarning("Drop called but no drop target date set");
            OnDragEnd();
            return;
        }

        try
        {
           // Find the work item to get its current dates
            var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == draggedWorkItemId.Value);
            if (workItem == null)
            {
                Logger.LogWarning("Work item {WorkItemId} not found in local data", draggedWorkItemId.Value);
                OnDragEnd();
                return;
            }

            var currentStartDate = workItem.Fields.TryGetValue("Microsoft.VSTS.Scheduling.StartDate", out var startDateObj) && startDateObj is DateTime sd
                ? (DateTime?)sd
                : null;
            
            var currentTargetDate = workItem.TargetDate;
            DateTime? newStartDate = null;
            
            // If there's a start date and target date, preserve the duration
            if (currentStartDate.HasValue && currentTargetDate.HasValue && dropTargetDate.HasValue)
            {
                var durationDays = (currentTargetDate.Value - currentStartDate.Value).Days;
                newStartDate = dropTargetDate.Value.AddDays(-durationDays);
                
                Logger.LogInformation("Preserving duration: {Duration} days. Old: {OldStart} to {OldTarget}, New: {NewStart} to {NewTarget}",
                    durationDays, currentStartDate.Value, currentTargetDate.Value, newStartDate.Value, dropTargetDate.Value);
            }
            else
            {
                Logger.LogInformation("No start date to shift, setting only target date");
            }
            
            var wasUnscheduled = !currentTargetDate.HasValue;
            await UpdateLocalWorkItemDates(draggedWorkItemId.Value, newStartDate, dropTargetDate.Value, wasUnscheduled);
            StateHasChanged();
            
            Logger.LogInformation("Updating work item {WorkItemId} with start date {StartDate} and target date {TargetDate}", 
                draggedWorkItemId.Value, newStartDate, dropTargetDate.Value);
            
            var success = await RoadmapService.UpdateWorkItemDatesAsync(draggedWorkItemId.Value, newStartDate, dropTargetDate.Value);
            
            if (success)
            {
                Logger.LogInformation("Successfully updated work item {WorkItemId}", draggedWorkItemId.Value);
                var message = newStartDate != null
                    ? $"Work item {draggedWorkItemId.Value} moved to {newStartDate.Value:M/d/yyyy} - {dropTargetDate.Value:M/d/yyyy}"
                    : $"Work item {draggedWorkItemId.Value} scheduled to {dropTargetDate.Value:M/d/yyyy}";
                
                Snackbar.Add(message, Severity.Success);
                
                // Mark that a drag operation occurred
                wasResizeOrDragOperation = true;
                lastResizeOrDragTime = DateTime.UtcNow;
            }
            else
            {
                Logger.LogError("Failed to update work item {WorkItemId}, reverting changes", draggedWorkItemId.Value);
                
                await UpdateLocalWorkItemDates(draggedWorkItemId.Value, currentStartDate, currentTargetDate, !wasUnscheduled);
                StateHasChanged();
                
                Snackbar.Add($"Failed to update work item {draggedWorkItemId.Value}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in timeline drop handler for work item {WorkItemId}", draggedWorkItemId);
            Snackbar.Add($"Error updating work item: {ex.Message}", Severity.Error);
            
            await LoadRoadmapDataAsync();
            await ReinitializeJavaScriptModuleAsync();
        }
        finally
        {
            OnDragEnd();
        }
    }

    private async Task HandleUnscheduleDrop()
    {
        Logger.LogInformation("HandleUnscheduleDrop called. DraggedItemId: {ItemId}", draggedWorkItemId);
        
        if (!draggedWorkItemId.HasValue)
        {
            OnDragEnd();
            return;
        }

        try
        {
            var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == draggedWorkItemId.Value);
            if (workItem == null)
            {
                Logger.LogWarning("Work item {WorkItemId} not found in local data", draggedWorkItemId.Value);
                OnDragEnd();
                return;
            }

            var originalStartDate = workItem.Fields.TryGetValue("Microsoft.VSTS.Scheduling.StartDate", out var startDateObj) && startDateObj is DateTime sd
                ? (DateTime?)sd
                : null;
            var originalTargetDate = workItem.TargetDate;
            
            Logger.LogInformation("Clearing target date for work item {WorkItemId}", draggedWorkItemId.Value);
            
            await UpdateLocalWorkItemDates(draggedWorkItemId.Value, null, null, true);
            StateHasChanged();
            
            var success = await RoadmapService.UpdateWorkItemDatesAsync(draggedWorkItemId.Value, null, null);
            
            if (success)
            {
                Snackbar.Add($"Work item {draggedWorkItemId.Value} unscheduled successfully", Severity.Success);
                
                // Mark that a drag operation occurred
                wasResizeOrDragOperation = true;
                lastResizeOrDragTime = DateTime.UtcNow;
            }
            else
            {
                Logger.LogError("Failed to update work item {WorkItemId}, reverting changes", draggedWorkItemId.Value);
                
                await UpdateLocalWorkItemDates(draggedWorkItemId.Value, originalStartDate, originalTargetDate, false);
                StateHasChanged();
                
                Snackbar.Add($"Failed to update work item {draggedWorkItemId.Value}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in unschedule drop handler");
            Snackbar.Add($"Error updating work item: {ex.Message}", Severity.Error);
            
            await LoadRoadmapDataAsync();
            await ReinitializeJavaScriptModuleAsync();
        }
        finally
        {
            OnDragEnd();
        }
    }

    private async Task OpenScheduleDialog(int workItemId)
    {
        // Prevent opening dialog if a resize or drag operation just completed
        // (within 500ms to account for the time between mouseup and click events)
        if (wasResizeOrDragOperation && (DateTime.UtcNow - lastResizeOrDragTime).TotalMilliseconds < 500)
        {
            Logger.LogInformation("Ignoring click event - resize/drag operation just completed");
            wasResizeOrDragOperation = false;
            return;
        }
        
        selectedWorkItemId = workItemId;
        selectedWorkItem = allWorkItems?.FirstOrDefault(wi => wi.Id == workItemId);

        if (selectedWorkItem != null)
        {
            scheduleStartDate = selectedWorkItem.Fields.TryGetValue("Microsoft.VSTS.Scheduling.StartDate", out var startDateObj) && startDateObj is DateTime startDate
                ? startDate
                : null;
            scheduleTargetDate = selectedWorkItem.TargetDate;
            selectedWorkItemState = selectedWorkItem.State;
            
            availableStates = await RoadmapService.GetAvailableStatesForWorkItemTypeAsync(selectedWorkItem.WorkItemType, currentProcessId);

            scheduleDialogVisible = true;
        }
    }

    private void CloseScheduleDialog()
    {
        scheduleDialogVisible = false;
        selectedWorkItemId = 0;
        selectedWorkItem = null;
        scheduleStartDate = null;
        scheduleTargetDate = null;
        selectedWorkItemState = null;
        availableStates.Clear();
    }

    private async Task SaveWorkItem()
    {
        if (selectedWorkItemId <= 0 || selectedWorkItem == null) return;

        try
        {
            var updates = new List<string>();

            var currentStartDate = selectedWorkItem.Fields.TryGetValue("Microsoft.VSTS.Scheduling.StartDate", out var startDateObj) && startDateObj is DateTime sd
                ? (DateTime?)sd
                : null;
            
            var startDateChanged = scheduleStartDate != currentStartDate;
            var targetDateChanged = scheduleTargetDate != selectedWorkItem.TargetDate;
            var stateChanged = !string.IsNullOrEmpty(selectedWorkItemState) && selectedWorkItemState != selectedWorkItem.State;

            if (!startDateChanged && !targetDateChanged && !stateChanged)
            {
                CloseScheduleDialog();
                return;
            }

            var originalStartDate = currentStartDate;
            var originalTargetDate = selectedWorkItem.TargetDate;
            var originalState = selectedWorkItem.State;

            if (targetDateChanged)
            {
                var action = scheduleTargetDate.HasValue ? "scheduled" : "unscheduled";
                updates.Add(action);
            }

            if (startDateChanged && scheduleStartDate.HasValue)
            {
                updates.Add($"start date set to {scheduleStartDate.Value:M/d/yyyy}");
            }
            else if (startDateChanged && !scheduleStartDate.HasValue)
            {
                updates.Add("start date cleared");
            }

            if (stateChanged)
            {
                updates.Add($"state changed to {selectedWorkItemState}");
            }

            var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == selectedWorkItemId);
            if (workItem != null)
            {
                if (targetDateChanged)
                    workItem.TargetDate = scheduleTargetDate;
                
                if (startDateChanged)
                {
                    if (scheduleStartDate.HasValue)
                        workItem.Fields["Microsoft.VSTS.Scheduling.StartDate"] = scheduleStartDate.Value;
                    else
                        workItem.Fields.Remove("Microsoft.VSTS.Scheduling.StartDate");
                }
                
                if (stateChanged && !string.IsNullOrEmpty(selectedWorkItemState))
                    workItem.State = selectedWorkItemState;

                if (targetDateChanged)
                {
                    var moveToUnscheduled = !scheduleTargetDate.HasValue;
                    await UpdateLocalWorkItemDates(selectedWorkItemId, scheduleStartDate, scheduleTargetDate, moveToUnscheduled);
                }
            }

            CloseScheduleDialog();
            StateHasChanged();

            var success = await RoadmapService.UpdateWorkItemFieldsAsync(
                selectedWorkItemId,
                scheduleStartDate,
                scheduleTargetDate,
                stateChanged ? selectedWorkItemState : null,
                updateStartDate: startDateChanged,
                updateTargetDate: targetDateChanged
            );

            if (success)
            {
                var message = $"Work item {selectedWorkItemId} updated: {string.Join(", ", updates)}";
                Snackbar.Add(message, Severity.Success);
            }
            else
            {
                Logger.LogError("Failed to update work item {WorkItemId}, reverting changes", selectedWorkItemId);
                
                if (workItem != null)
                {
                    workItem.TargetDate = originalTargetDate;
                    workItem.State = originalState;
                    
                    if (originalStartDate.HasValue)
                        workItem.Fields["Microsoft.VSTS.Scheduling.StartDate"] = originalStartDate.Value;
                    else
                        workItem.Fields.Remove("Microsoft.VSTS.Scheduling.StartDate");

                    if (targetDateChanged)
                    {
                        var moveToUnscheduled = !originalTargetDate.HasValue;
                        await UpdateLocalWorkItemDates(selectedWorkItemId, originalStartDate, originalTargetDate, moveToUnscheduled);
                    }
                }
                
                StateHasChanged();
                Snackbar.Add($"Failed to update work item {selectedWorkItemId}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving work item {WorkItemId}", selectedWorkItemId);
            Snackbar.Add($"Error saving work item: {ex.Message}", Severity.Error);
            
            await LoadRoadmapDataAsync();
            await ReinitializeJavaScriptModuleAsync();
        }
    }

    private async Task UpdateLocalWorkItemDates(int workItemId, DateTime? startDate, DateTime? targetDate, bool moveToUnscheduled)
    {
        var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == workItemId);
        if (workItem == null) return;

        workItem.TargetDate = targetDate;
        if (startDate.HasValue)
            workItem.Fields["Microsoft.VSTS.Scheduling.StartDate"] = startDate.Value;
        else
            workItem.Fields.Remove("Microsoft.VSTS.Scheduling.StartDate");

        if (moveToUnscheduled)
        {
            await MoveItemToUnscheduled(workItemId);
        }
        else
        {
            await MoveItemToScheduled(workItemId, startDate, targetDate);
        }
    }

    private async Task MoveItemToUnscheduled(int workItemId)
    {
        var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == workItemId);
        if (workItem == null) return;

        RemoveItemFromSwimlanes(workItemId, swimlanes);

        if (unscheduledItems?.Any(ui => ui.WorkItemId == workItemId) == true)
            return;

        var parentChildMap = new Dictionary<int, List<int>>();
        BuildParentLookupFromSwimlanes(swimlanes, parentChildMap);
        
        var parentId = parentChildMap.FirstOrDefault(kvp => kvp.Value.Contains(workItemId)).Key;
        var parentWorkItem = parentId > 0 ? allWorkItems?.FirstOrDefault(w => w.Id == parentId) : null;

        var unscheduledItem = new UnscheduledWorkItem
        {
            WorkItemId = workItem.Id,
            Title = workItem.Title,
            WorkItemType = workItem.WorkItemType,
            Color = workItem.Color,
            State = workItem.State,
            StateCategory = workItem.StateCategory,
            AssignedTo = workItem.AssignedToDisplayName,
            ParentId = parentId,
            ParentTitle = parentWorkItem?.Title ?? string.Empty,
            ParentType = parentWorkItem?.WorkItemType ?? string.Empty
        };

        unscheduledItems ??= new List<UnscheduledWorkItem>();
        unscheduledItems.Add(unscheduledItem);
        unscheduledItems = unscheduledItems.OrderBy(ui => ui.ParentTitle).ThenBy(ui => ui.Title).ToList();

        await Task.CompletedTask;
    }

    private async Task MoveItemToScheduled(int workItemId, DateTime? startDate, DateTime? targetDate)
    {
        var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == workItemId);
        if (workItem == null || !targetDate.HasValue) return;

        if (unscheduledItems != null)
        {
            unscheduledItems = unscheduledItems.Where(ui => ui.WorkItemId != workItemId).ToList();
        }

        var swimlane = FindSwimlaneForWorkItem(workItemId, swimlanes);
        
        if (swimlane != null)
        {
            var existingTimelineItem = swimlane.TimelineItems?.FirstOrDefault(ti => ti.WorkItemId == workItemId);
            
            if (existingTimelineItem != null)
            {
                existingTimelineItem.StartDate = startDate;
                existingTimelineItem.TargetDate = targetDate;
            }
            else
            {
                swimlane.TimelineItems ??= new List<TimelineItem>();
                swimlane.TimelineItems.Add(new TimelineItem
                {
                    WorkItemId = workItem.Id,
                    Title = workItem.Title,
                    WorkItemType = workItem.WorkItemType,
                    Color = workItem.Color,
                    StartDate = startDate,
                    TargetDate = targetDate,
                    State = workItem.State,
                    StateCategory = workItem.StateCategory,
                    AssignedTo = workItem.AssignedToDisplayName
                });
            }
        }

        await Task.CompletedTask;
    }

    private void RemoveItemFromSwimlanes(int workItemId, List<SwimLane>? swimlanes)
    {
        if (swimlanes == null) return;

        foreach (var swimlane in swimlanes)
        {
            if (swimlane.TimelineItems != null)
            {
                swimlane.TimelineItems = swimlane.TimelineItems.Where(ti => ti.WorkItemId != workItemId).ToList();
            }

            if (swimlane.Children != null)
            {
                RemoveItemFromSwimlanes(workItemId, swimlane.Children);
            }
        }
    }

    private SwimLane? FindSwimlaneForWorkItem(int workItemId, List<SwimLane>? swimlanes)
    {
        if (swimlanes == null) return null;

        foreach (var swimlane in swimlanes)
        {
            if (swimlane.WorkItemId == workItemId)
            {
                return swimlane;
            }

            if (swimlane.Children != null)
            {
                var found = FindSwimlaneForWorkItem(workItemId, swimlane.Children);
                if (found != null) return found;
            }
        }

        return null;
    }

    private void BuildParentLookupFromSwimlanes(List<SwimLane>? swimlanes, Dictionary<int, List<int>> parentLookup)
    {
        if (swimlanes == null) return;

        foreach (var swimlane in swimlanes)
        {
            if (swimlane.Children != null)
            {
                foreach (var child in swimlane.Children)
                {
                    if (!parentLookup.ContainsKey(swimlane.WorkItemId))
                    {
                        parentLookup[swimlane.WorkItemId] = new List<int>();
                    }
                    parentLookup[swimlane.WorkItemId].Add(child.WorkItemId);
                }

                BuildParentLookupFromSwimlanes(swimlane.Children, parentLookup);
            }
        }
    }

    private int GetPixelsPerDay() => config.TimeUnit switch
    {
        TimeUnit.Week => 10,
        TimeUnit.Month => 3,
        TimeUnit.Quarter => 1,
        _ => 3
    };

    private string GetColorWithFallback(string? color) => !string.IsNullOrEmpty(color) ? color : "#6C757D";
    private string GetUnscheduledItemStyle(UnscheduledWorkItem item) => $"background-color: {GetColorWithFallback(item.Color)}; border-radius: 4px; cursor: move;";
    private string GetPeriodStyle(TimelinePeriod period) => $"width: {period.Width}px; min-width: {period.Width}px;";
    private bool HasChildren(SwimLane swimlane) => swimlane.Children?.Any() == true;

    private string GetTimelineContentWidthStyle()
    {
        var periods = GetTimelinePeriods();
        var totalWidth = periods.Sum(p => p.Width);
        return $"min-width: {totalWidth}px; width: {totalWidth}px;";
    }

    private List<TimelinePeriod> GetTimelinePeriods()
    {
        var periods = new List<TimelinePeriod>();
        var pixelsPerDay = GetPixelsPerDay();

        if (config.TimeUnit == TimeUnit.Week)
        {
            var current = config.StartDate;
            while (current <= config.EndDate)
            {
                var weekStart = current;
                var weekEnd = current.AddDays(6);
                if (weekEnd > config.EndDate) weekEnd = config.EndDate;
                
                var weekNumber = System.Globalization.ISOWeek.GetWeekOfYear(weekStart);
                var daysInWeek = (weekEnd - weekStart).Days + 1;
                
                periods.Add(new TimelinePeriod
                {
                    Label = $"Week {weekNumber}",
                    SubLabel = $"{weekStart:MMM d} - {weekEnd:MMM d}",
                    Width = daysInWeek * pixelsPerDay,
                    StartDate = weekStart,
                    EndDate = weekEnd
                });
                current = weekEnd.AddDays(1);
            }
        }
        else if (config.TimeUnit == TimeUnit.Month)
        {
            var current = GetAlignedStartDate();
            while (current <= config.EndDate)
            {
                var daysInMonth = DateTime.DaysInMonth(current.Year, current.Month);
                periods.Add(new TimelinePeriod
                {
                    Label = current.ToString("MMM yyyy"),
                    SubLabel = $"{daysInMonth} days",
                    Width = daysInMonth * pixelsPerDay,
                    StartDate = current,
                    EndDate = current.AddMonths(1).AddDays(-1)
                });
                current = current.AddMonths(1);
            }
        }
        else if (config.TimeUnit == TimeUnit.Quarter)
        {
            var current = GetAlignedStartDate();
            while (current <= config.EndDate)
            {
                var quarter = (current.Month - 1) / 3 + 1;
                var endOfQuarter = current.AddMonths(3).AddDays(-1);
                var daysInQuarter = (endOfQuarter - current).Days + 1;
                
                periods.Add(new TimelinePeriod
                {
                    Label = $"Q{quarter} {current.Year}",
                    SubLabel = $"{current:MMM} - {endOfQuarter:MMM}",
                    Width = daysInQuarter * pixelsPerDay,
                    StartDate = current,
                    EndDate = endOfQuarter
                });
                current = current.AddMonths(3);
            }
        }

        return periods;
    }

    private class TimelinePeriod
    {
        public string Label { get; set; } = string.Empty;
        public string SubLabel { get; set; } = string.Empty;
        public double Width { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime EndDate { get; set; }
    }

    private string GetDateRangeDisplay(TimelineItem item)
    {
        if (!item.TargetDate.HasValue) return "No target date";
        if (!item.StartDate.HasValue) return $"- {item.TargetDate.Value:M/d/yyyy}";
        return $"{item.StartDate.Value:M/d/yyyy} - {item.TargetDate.Value:M/d/yyyy}";
    }

    private RenderFragment RenderSwimLaneLabel(SwimLane swimlane, int level) => __builder =>
    {
        var indentStyle = $"padding-left: {level * 20 + 8}px;";
        var backgroundColor = GetColorWithFallback(swimlane.Color);
        
        <div class="timeline-row" style="@indentStyle">
            <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
                @if (HasChildren(swimlane))
                {
                    <MudIconButton Icon="@(swimlane.IsCollapsed ? Icons.Material.Filled.ChevronRight : Icons.Material.Filled.ExpandMore)" Size="Size.Small" OnClick="@(() => ToggleCollapse(swimlane))" />
                }
                else
                {
                    <div style="width: 24px;"></div>
                }
                <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(swimlane.WorkItemType)" Size="Size.Small" Style="@($"color: {backgroundColor};")" />
                <MudText Typo="Typo.body2" Style="font-weight: 500;">@swimlane.WorkItemId - @swimlane.Title</MudText>
            </MudStack>
        </div>

        @if (!swimlane.IsCollapsed && HasChildren(swimlane))
        {
            @foreach (var child in swimlane.Children!)
            {
                @RenderSwimLaneLabel(child, level + 1)
            }
        }
    };

    private RenderFragment RenderSwimLaneTimeline(SwimLane swimlane, int level) => __builder =>
    {
        <div class="timeline-row">
            @if (swimlane.TimelineItems?.Any() == true)
            {
                @foreach (var item in swimlane.TimelineItems.Where(ti => ti.TargetDate.HasValue))
                {
                    if (!item.TargetDate.HasValue) continue;

                    try
                    {
                        var position = CalculateItemPosition(item);
                        if (position.Width == 0) continue;
                        
                        var itemStyle = $"left: {position.Left}px; width: {position.Width}px; background-color: {item.Color};";
                        var itemClass = draggedWorkItemId == item.WorkItemId ? "timeline-item dragging" : "timeline-item";
                        var dateRange = GetDateRangeDisplay(item);
                        
                        <div class="@itemClass" style="@itemStyle" title="@($"{item.Title} - {dateRange}")" draggable="true" @ondragstart="@(() => OnDragStart(item.WorkItemId))" @ondragend="@OnDragEnd" @ondblclick="@(async () => await OpenScheduleDialog(item.WorkItemId))">
                            <MudStack Spacing="0" Style="padding: 2px 4px;">
                                <MudText Typo="Typo.caption" Style="color: white; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 500;">
                                    @item.WorkItemId - @item.Title
                                </MudText>
                                <MudText Typo="Typo.caption" Style="color: rgba(255,255,255,0.9); font-size: 0.65rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                    @dateRange
                                </MudText>
                            </MudStack>
                        </div>
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning(ex, "Error rendering timeline item {ItemId}", item.WorkItemId);
                    }
                }
            }
        </div>

        @if (!swimlane.IsCollapsed && HasChildren(swimlane))
        {
            @foreach (var child in swimlane.Children!)
            {
                @RenderSwimLaneTimeline(child, level + 1)
            }
        }
    };

    private void ToggleCollapse(SwimLane swimlane)
    {
        swimlane.IsCollapsed = !swimlane.IsCollapsed;
        StateHasChanged();
    }

    private (double Left, double Width) CalculateItemPosition(TimelineItem item)
    {
        if (!item.TargetDate.HasValue) 
        {
            Logger.LogWarning("CalculateItemPosition called for item {ItemId} with no target date", item.WorkItemId);
            return (0, 0);
        }

        try
        {
            var pixelsPerDay = GetPixelsPerDay();
            var startDate = item.StartDate ?? item.TargetDate.Value.AddDays(-90);
            var endDate = item.TargetDate.Value;
            var timelineStart = GetAlignedStartDate();
            
            var daysFromStart = (startDate - timelineStart).TotalDays;
            var duration = (endDate - startDate).TotalDays;

            var left = Math.Max(0, daysFromStart * pixelsPerDay);
            var width = Math.Max(20, duration * pixelsPerDay);

            return (left, width);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error calculating position for item {ItemId}. StartDate: {Start}, TargetDate: {Target}", 
                item.WorkItemId, item.StartDate, item.TargetDate);
            return (0, 0);
        }
    }
    
    private DateTime GetAlignedStartDate()
    {
        return config.TimeUnit switch
        {
            TimeUnit.Week => config.StartDate,
            TimeUnit.Month => new DateTime(config.StartDate.Year, config.StartDate.Month, 1),
            TimeUnit.Quarter => new DateTime(config.StartDate.Year, ((config.StartDate.Month - 1) / 3) * 3 + 1, 1),
            _ => config.StartDate
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (jsModule != null)
        {
            try
            {
                await jsModule.InvokeVoidAsync("dispose");
                await jsModule.DisposeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing JavaScript module");
            }
        }

        dotNetRef?.Dispose();
    }
}
