@page "/roadmap"
@using AzDoBoards.Client.Models
@using AzDoBoards.Ui.Services
@using AzDoBoards.Utility
@using AzDoBoards.Utility.Models
@using Microsoft.AspNetCore.Components.Authorization
@using MudBlazor
@inject RoadmapService RoadmapService
@inject HierarchyService HierarchyService
@inject RoadmapDragDropService DragDropService
@inject ISnackbar Snackbar
@inject ILogger<Roadmap> Logger
@inject AuthenticationStateProvider AuthStateProvider
@inject IJSRuntime JSRuntime

<PageTitle>Roadmap</PageTitle>

<div class="page-content-full-width mt-4">
    @if (isLoading)
    {
        <MudContainer MaxWidth="MaxWidth.False" Class="d-flex justify-center align-center" Style="height: 200px;">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudProgressCircular Indeterminate="true" Size="Size.Large" />
                <MudText Typo="Typo.h6">Loading roadmap data...</MudText>
            </MudStack>
        </MudContainer>
    }
    else if (!isAuthenticated)
    {
        <MudAlert Severity="Severity.Warning" Class="mb-4">
            <MudText>Please sign in to view the roadmap.</MudText>
        </MudAlert>
    }
    else if (!hasConfiguration)
    {
        <MudAlert Severity="Severity.Info" Class="mb-4">
            <MudText>Please configure your work item hierarchy in Settings > Process to enable the roadmap view.</MudText>
        </MudAlert>
    }
    else
    {
        <div class="roadmap-container">
            <!-- Roadmap Toolbar -->
            <div class="roadmap-toolbar">
                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudStack Row AlignItems="AlignItems.Center" Spacing="3">
                        <MudText Typo="Typo.h5">Roadmap</MudText>
                        <MudDivider Vertical="true" />
                        
                        <!-- Date Range Controls -->
                        <MudDatePicker Date="configuration.StartDate" 
                                     DateChanged="OnStartDateChanged"
                                     Label="Start Date" 
                                     Variant="Variant.Outlined" />
                        
                        <MudDatePicker Date="configuration.EndDate" 
                                     DateChanged="OnEndDateChanged"
                                     Label="End Date" 
                                     Variant="Variant.Outlined" />
                        
                        <!-- Time Unit Selector -->
                        <MudSelect T="RoadmapTimeUnit" 
                                 Value="configuration.TimeUnit" 
                                 ValueChanged="OnTimeUnitChanged"
                                 Label="Time Unit" 
                                 Variant="Variant.Outlined">
                            <MudSelectItem Value="RoadmapTimeUnit.Week">Week</MudSelectItem>
                            <MudSelectItem Value="RoadmapTimeUnit.Month">Month</MudSelectItem>
                            <MudSelectItem Value="RoadmapTimeUnit.Quarter">Quarter</MudSelectItem>
                        </MudSelect>
                    </MudStack>
                    
                    <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                        <MudCheckBox Value="configuration.ShowDependencies" 
                                   ValueChanged="@(async (bool value) => await OnShowDependenciesChanged(value))"
                                   Label="Show Dependencies" 
                                   Color="Color.Primary" />
                        
                        <MudIconButton Icon="@Icons.Material.Filled.Refresh" 
                                     OnClick="LoadRoadmapDataAsync" 
                                     Variant="Variant.Filled" 
                                     Color="Color.Primary" 
                                     data-title="Refresh Data" />
                    </MudStack>
                </MudStack>
            </div>

            <!-- Unscheduled Column -->
            <div class="roadmap-unscheduled-column">
                <MudText Typo="Typo.subtitle1" Class="mb-3">
                    <MudIcon Icon="@Icons.Material.Filled.Schedule" Class="mr-2" />
                    Unscheduled (@(unscheduledItems?.Count ?? 0))
                </MudText>
                
                @if (unscheduledItems?.Any() == true)
                {
                    <!-- Direct rendering for testing -->
                    <div class="unscheduled-items-container">
                        @foreach (var item in unscheduledItems)
                        {
                            <div class="unscheduled-item" 
                                 style="--item-color: @item.Color"
                                 draggable="true"
                                 @ondragstart="@((e) => OnUnscheduledDragStart(e, item))"
                                 @ondragend="@((e) => OnUnscheduledDragEnd(e, item))">
                                <div class="unscheduled-item-header">
                                    <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(item.WorkItemType)" Size="Size.Small" Class="mr-2" />
                                    <span class="unscheduled-item-id">@item.WorkItemId: </span>
                                    <span class="unscheduled-item-title">@item.Title</span>
                                </div>
                                
                                <div class="unscheduled-item-details">
                                    <span class="unscheduled-item-type">@item.WorkItemType</span>
                                    @if (!string.IsNullOrEmpty(item.AssignedTo))
                                    {
                                        <span class="unscheduled-item-assigned">@item.AssignedTo</span>
                                    }
                                    <MudIcon Icon="@Icons.Material.Filled.DragIndicator" Size="Size.Small" Class="ml-auto" />
                                </div>
                                @if (!string.IsNullOrEmpty(item.ParentTitle))
                                {
                                    <MudText Typo="Typo.caption" Class="unscheduled-item-parent mt-1">
                                        Parent: @item.ParentTitle
                                    </MudText>
                                }
                            </div>
                        }
                    </div>
                }
                else
                {
                    <MudAlert Severity="Severity.Success">
                        All @string.Join("/", lowestLevelWorkItemTypes) are scheduled.
                    </MudAlert>
                }
            </div>

            <!-- Timeline Column -->
            <div class="roadmap-timeline-column" id="timeline-column"
                 @ondrop="@OnTimelineDrop"
                 @ondragover:preventDefault="true"
                 @ondragenter="@OnTimelineDragEnter"
                 @ondragleave="@OnTimelineDragLeave"
                 onmousemove="if(event.buttons === 0 && window.roadmapDateCalculator) window.roadmapDateCalculator.updateIndicatorPosition(event.clientX)"
                 ondragover="if(window.roadmapDateCalculator) { window.roadmapDateCalculator.updateIndicatorPosition(event.clientX); event.dataTransfer.dropEffect = 'move'; }">
                
                <!-- Date Drop Indicator -->
                <div class="date-drop-indicator" id="date-drop-indicator"></div>
                
                <!-- Timeline Header -->
                <div class="timeline-header" id="timeline-header">
                    <div class="timeline-months">
                        @foreach (var month in GetTimelineMonths())
                        {
                            <div class="timeline-month" 
                                 style="width: @(month.Width)%;"
                                 title="Drop items here to schedule for @month.Label">
                                @month.Label
                            </div>
                        }
                    </div>
                    <div class="timeline-weeks">
                        @foreach (var week in GetTimelineWeeks())
                        {
                            <div class="timeline-week" 
                                 style="width: @(week.Width)%;"
                                 title="Week starting @week.Label">
                                @week.Label
                            </div>
                        }
                    </div>
                </div>

                <!-- Swimlanes -->
                <div class="roadmap-swimlanes">
                    @if (swimlanes?.Any() == true)
                    {
                        @foreach (var swimlane in swimlanes)
                        {
                            <div class="roadmap-swimlane">
                                <div class="swimlane-header level-@swimlane.Level" 
                                     @onclick="() => ToggleSwimlane(swimlane.WorkItemId)">
                                    <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(swimlane.WorkItemType)" Size="Size.Small" Class="mr-2" />
                                    <MudText Class="flex-grow-1">@swimlane.WorkItemId: @swimlane.Title</MudText>
                                    @if (swimlane.Children.Any())
                                    {
                                        <MudIcon Icon="@(swimlane.IsCollapsed ? Icons.Material.Filled.ChevronRight : Icons.Material.Filled.ExpandMore)" />
                                    }
                                </div>
                                
                                <div class="swimlane-content">
                                    <!-- Timeline Drop Zone -->
                                    <MudDropContainer T="RoadmapTimelineItem" 
                                                    Items="swimlane.TimelineItems" 
                                                    ItemDropped="(item) => OnTimelineItemDropped(item, swimlane.WorkItemId)"
                                                    Class="timeline-drop-zone"
                                                    @ondragover="OnTimelineDragOver">
                                        <ChildContent>
                                            <MudDropZone T="RoadmapTimelineItem" 
                                                       Identifier="@($"timeline-{swimlane.WorkItemId}")" 
                                                       Class="timeline-drop-zone">
                                            </MudDropZone>
                                        </ChildContent>
                                        <ItemRenderer>
                                            <div class="timeline-item" 
                                                 style="--item-color: @context.Color; left: @(context.LeftPosition)%; width: @(context.Width)%; top: @(context.SwimLaneLevel * 36)px;"
                                                 draggable="true"
                                                 @onclick="() => ShowWorkItemDetails(context)">
                                                <span class="flex-grow-1">@GetDisplayTitle(context.Title)</span>
                                                @if (!string.IsNullOrEmpty(context.AssignedTo))
                                                {
                                                    <MudTooltip Text="@context.AssignedTo">
                                                        <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" Class="mr-1" />
                                                    </MudTooltip>
                                                }
                                                <MudIcon Icon="@Icons.Material.Filled.DragIndicator" Class="move-icon" Size="Size.Small" />
                                            </div>
                                        </ItemRenderer>
                                    </MudDropContainer>
                                </div>
                                
                                @if (!swimlane.IsCollapsed && swimlane.Children.Any())
                                {
                                    <div class="swimlane-children" id="swimlane-children-@swimlane.WorkItemId">
                                        @foreach (var childSwimlane in swimlane.Children)
                                        {
                                            <div class="roadmap-swimlane">
                                                <div class="swimlane-header level-@childSwimlane.Level">
                                                    <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(childSwimlane.WorkItemType)" Size="Size.Small" Class="mr-2" />
                                                    <MudText Class="flex-grow-1">@childSwimlane.WorkItemId: @childSwimlane.Title</MudText>
                                                </div>
                                                
                                                <div class="swimlane-content">
                                                    <MudDropContainer T="RoadmapTimelineItem" 
                                                                    Items="childSwimlane.TimelineItems" 
                                                                    ItemDropped="(item) => OnTimelineItemDropped(item, childSwimlane.WorkItemId)"
                                                                    Class="timeline-drop-zone">
                                                        <ChildContent>
                                                            <MudDropZone T="RoadmapTimelineItem" 
                                                                       Identifier="@($"timeline-{childSwimlane.WorkItemId}")" 
                                                                       Class="timeline-drop-zone">
                                                            </MudDropZone>
                                                        </ChildContent>
                                                        <ItemRenderer>
                                                            <div class="timeline-item" 
                                                                 style="--item-color: @context.Color; left: @(context.LeftPosition)%; width: @(context.Width)%; top: @(context.SwimLaneLevel * 36)px;"
                                                                 draggable="true"
                                                                 @onclick="() => ShowWorkItemDetails(context)">
                                                                <span class="flex-grow-1">@GetDisplayTitle(context.Title)</span>
                                                                @if (!string.IsNullOrEmpty(context.AssignedTo))
                                                                {
                                                                    <MudTooltip Text="@context.AssignedTo">
                                                                        <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" Class="mr-1" />
                                                                    </MudTooltip>
                                                                }
                                                                <MudIcon Icon="@Icons.Material.Filled.DragIndicator" Class="move-icon" Size="Size.Small" />
                                                            </div>
                                                        </ItemRenderer>
                                                    </MudDropContainer>
                                                </div>
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <div style="padding: 40px; text-align: center;">
                            <MudAlert Severity="Severity.Info">
                                No roadmap data available. Check your work item hierarchy configuration and ensure you have work items in the selected project.
                            </MudAlert>
                        </div>
                    }
                </div>

                <!-- Dependency Lines (SVG Overlay) -->
                @if (configuration.ShowDependencies)
                {
                    <svg class="dependency-lines-container">
                        <defs>
                            <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" class="dependency-arrow" />
                            </marker>
                        </defs>
                        @foreach (var dependency in GetVisibleDependencies())
                        {
                            <line class="dependency-line @(dependency.Type == DependencyType.Related ? "related" : "")"
                                  x1="@dependency.X1" y1="@dependency.Y1"
                                  x2="@dependency.X2" y2="@dependency.Y2" />
                        }
                    </svg>
                }
            </div>
        </div>
    }
</div>

<!-- Work Item Details Dialog -->
<MudDialog @bind-Visible="showWorkItemDialog" Options="dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(selectedWorkItem?.WorkItemType ?? "")" Class="mr-3" />
            @selectedWorkItem?.Title
        </MudText>
    </TitleContent>
    <DialogContent>
        @if (selectedWorkItem != null)
        {
            <MudGrid>
                <MudItem xs="6">
                    <MudTextField @bind-Value="selectedWorkItem.Title" 
                                Label="Title" 
                                Variant="Variant.Outlined" 
                                ReadOnly="true" />
                </MudItem>
                <MudItem xs="6">
                    <MudTextField @bind-Value="selectedWorkItem.WorkItemType" 
                                Label="Type" 
                                Variant="Variant.Outlined" 
                                ReadOnly="true" />
                </MudItem>
                <MudItem xs="6">
                    <MudTextField @bind-Value="selectedWorkItem.State" 
                                Label="State" 
                                Variant="Variant.Outlined" 
                                ReadOnly="true" />
                </MudItem>
                <MudItem xs="6">
                    <MudTextField @bind-Value="selectedWorkItem.AssignedTo" 
                                Label="Assigned To" 
                                Variant="Variant.Outlined" 
                                ReadOnly="true" />
                </MudItem>
                <MudItem xs="12">
                    <MudDatePicker @bind-Date="selectedWorkItemTargetDate" 
                                 Label="Target Date" 
                                 Variant="Variant.Outlined" />
                </MudItem>
            </MudGrid>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseWorkItemDialog">Cancel</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="SaveWorkItemChanges">Save</MudButton>
    </DialogActions>
</MudDialog>

@code {
    private bool isLoading = true;
    private bool isAuthenticated = false;
    private bool hasConfiguration = false;

    private string currentProcessId = string.Empty;
    private string currentProjectId = string.Empty;
    
    private List<string> topLevelWorkItemTypes = new();
    private List<string> parentLevelWorkItemTypes = new();
    private List<string> lowestLevelWorkItemTypes = new();
    
    private List<WorkItem> allWorkItems = new();
    private List<RoadmapSwimLane> swimlanes = new();
    private List<UnscheduledWorkItem>? unscheduledItems = new();
    
    private RoadmapConfiguration configuration = new();
    
    // Dialog state
    private bool showWorkItemDialog = false;
    private RoadmapTimelineItem? selectedWorkItem = null;
    private DateTime? selectedWorkItemTargetDate = null;
    private DialogOptions dialogOptions = new() { MaxWidth = MaxWidth.Medium, FullWidth = true };

    // Drag and drop state
    private UnscheduledWorkItem? currentDraggedItem = null;
    private bool isDragging = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadRoadmapDataAsync();
    }

    private async Task LoadRoadmapDataAsync()
    {
        isLoading = true;
        StateHasChanged();

        try
        {
            // Check authentication
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            isAuthenticated = authState.User?.Identity?.IsAuthenticated ?? false;

            if (!isAuthenticated)
            {
                isLoading = false;
                StateHasChanged();
                return;
            }

            // Load current configuration
            currentProcessId = await HierarchyService.GetCurrentProcessIdAsync();
            currentProjectId = await HierarchyService.GetCurrentProjectIdAsync(currentProcessId);

            Logger.LogInformation("ProcessId: {ProcessId}, ProjectId: {ProjectId}", currentProcessId, currentProjectId);

            if (string.IsNullOrEmpty(currentProcessId) || string.IsNullOrEmpty(currentProjectId))
            {
                hasConfiguration = false;
                isLoading = false;
                StateHasChanged();
                return;
            }

            // Load hierarchy configuration
            var hierarchyLevels = await RoadmapService.GetRoadmapHierarchyLevelsAsync(currentProcessId);
            Logger.LogInformation("Loaded {HierarchyLevelCount} hierarchy levels", hierarchyLevels.Count);
            
            if (!hierarchyLevels.Any())
            {
                hasConfiguration = false;
                isLoading = false;
                StateHasChanged();
                return;
            }

            hasConfiguration = true;

            // Load work item types for each level
            topLevelWorkItemTypes = await RoadmapService.GetTopLevelWorkItemTypesAsync(currentProcessId);
            parentLevelWorkItemTypes = await RoadmapService.GetParentLevelWorkItemTypesAsync(currentProcessId);
            lowestLevelWorkItemTypes = await RoadmapService.GetLowestLevelWorkItemTypesAsync(currentProcessId);

            Logger.LogInformation("Work item types - Top: {TopLevel}, Parent: {ParentLevel}, Lowest: {LowestLevel}", 
                string.Join(", ", topLevelWorkItemTypes), 
                string.Join(", ", parentLevelWorkItemTypes), 
                string.Join(", ", lowestLevelWorkItemTypes));

            // Load configuration
            configuration = await RoadmapService.GetDefaultConfigurationAsync();

            // Load all work items
            allWorkItems = await RoadmapService.LoadRoadmapWorkItemsAsync(currentProjectId, currentProcessId);
            Logger.LogInformation("Loaded {AllWorkItemsCount} total work items", allWorkItems.Count);

            // Build swimlanes structure
            swimlanes = await RoadmapService.BuildRoadmapSwimlanesAsync(allWorkItems, currentProcessId);
            Logger.LogInformation("Built {SwimlanesCount} swimlanes", swimlanes.Count);
            
            // Get unscheduled items
            unscheduledItems = await RoadmapService.GetUnscheduledWorkItemsAsync(allWorkItems, currentProcessId);
            Logger.LogInformation("Found {UnscheduledCount} unscheduled items", unscheduledItems?.Count ?? 0);
            
            // Calculate timeline positions
            foreach (var swimlane in swimlanes)
            {
                foreach (var child in swimlane.Children)
                {
                    child.TimelineItems = RoadmapService.CalculateTimelinePositions(child.TimelineItems, configuration);
                }
            }

            Logger.LogInformation("Loaded roadmap data: {Swimlanes} swimlanes, {Unscheduled} unscheduled items",
                swimlanes.Count, unscheduledItems?.Count ?? 0);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading roadmap data");
            Snackbar.Add($"Error loading roadmap data: {ex.Message}", Severity.Error);
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task OnConfigurationChanged()
    {
        try
        {
            await RoadmapService.SaveConfigurationAsync(configuration);
            
            // Update JavaScript calculator with new timeline data
            await JSRuntime.InvokeVoidAsync("roadmapDateCalculator.updateTimelineData",
                configuration.StartDate.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"),
                configuration.EndDate.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"));
            
            // Recalculate timeline positions with new configuration
            foreach (var swimlane in swimlanes)
            {
                foreach (var child in swimlane.Children)
                {
                    child.TimelineItems = RoadmapService.CalculateTimelinePositions(child.TimelineItems, configuration);
                }
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving configuration");
            Snackbar.Add("Error saving configuration", Severity.Error);
        }
    }

    private async Task OnStartDateChanged(DateTime? newDate)
    {
        if (newDate.HasValue)
        {
            configuration.StartDate = newDate.Value;
            await OnConfigurationChanged();
        }
    }

    private async Task OnEndDateChanged(DateTime? newDate)
    {
        if (newDate.HasValue)
        {
            configuration.EndDate = newDate.Value;
            await OnConfigurationChanged();
        }
    }

    private async Task OnTimeUnitChanged(RoadmapTimeUnit newTimeUnit)
    {
        configuration.TimeUnit = newTimeUnit;
        await OnConfigurationChanged();
    }

    private async Task OnShowDependenciesChanged(bool showDependencies)
    {
        configuration.ShowDependencies = showDependencies;
        await OnConfigurationChanged();
    }

    private void ToggleSwimlane(int workItemId)
    {
        var swimlane = FindSwimlaneById(workItemId);
        if (swimlane != null)
        {
            swimlane.IsCollapsed = !swimlane.IsCollapsed;
            StateHasChanged();
        }
    }

    private RoadmapSwimLane? FindSwimlaneById(int workItemId)
    {
        foreach (var swimlane in swimlanes)
        {
            if (swimlane.WorkItemId == workItemId)
                return swimlane;
            
            var child = swimlane.Children.FirstOrDefault(c => c.WorkItemId == workItemId);
            if (child != null)
                return child;
        }
        return null;
    }

    // Enhanced Drag and Drop Event Handlers
    private void OnUnscheduledDragStart(DragEventArgs e, UnscheduledWorkItem item)
    {
        currentDraggedItem = item;
        isDragging = true;
        e.DataTransfer.EffectAllowed = "move";
        Logger.LogInformation("Started dragging feature {WorkItemId}: {Title}", item.WorkItemId, item.Title);
    }

    private async Task OnUnscheduledDragEnd(DragEventArgs e, UnscheduledWorkItem item)
    {
        currentDraggedItem = null;
        isDragging = false;
        
        // Clean up visual indicators (fast, single call)
        await JSRuntime.InvokeVoidAsync("roadmapDateCalculator.hideIndicator");
        
        Logger.LogInformation("Ended dragging feature {WorkItemId}: {Title}", item.WorkItemId, item.Title);
    }

    // Enhanced Epic Drop Handler
    private async Task OnEpicDrop(DragEventArgs e, int epicId)
    {
        if (currentDraggedItem == null)
        {
            Logger.LogWarning("No dragged item found during epic drop");
            return;
        }

        try
        {
            Logger.LogInformation("Processing drop of {WorkItemId} onto epic {EpicId} at position ({ClientX}, {ClientY})", 
                currentDraggedItem.WorkItemId, epicId, e.ClientX, e.ClientY);

            Snackbar.Add($"Processing drop of {currentDraggedItem.Title}...", Severity.Info);

            // Use the drag drop service to process the drop
            var dropResult = await DragDropService.ProcessDropAsync(
                currentDraggedItem, 
                e.ClientX, 
                e.ClientY, 
                configuration.StartDate, 
                configuration.EndDate, 
                epicId);

            if (!dropResult.Success)
            {
                Logger.LogWarning("Drop validation failed: {ErrorMessage}", dropResult.ErrorMessage);
                Snackbar.Add($"? {dropResult.ErrorMessage}", Severity.Warning);
                if (!string.IsNullOrEmpty(dropResult.SuggestedAction))
                {
                    Snackbar.Add($"?? {dropResult.SuggestedAction}", Severity.Info);
                }
                return;
            }

            // Update the work item with calculated target date and parent
            var success = await RoadmapService.UpdateWorkItemTargetDateAndParentAsync(
                currentDraggedItem.WorkItemId, dropResult.TargetDate, epicId);

            if (success)
            {
                var epicName = FindSwimlaneById(epicId)?.Title ?? $"Epic {epicId}";
                Snackbar.Add($"? Assigned {currentDraggedItem.Title} to {epicName} for {dropResult.TargetDate:MMM dd, yyyy}", Severity.Success);
                
                Logger.LogInformation("Successfully updated work item {WorkItemId} - Target: {TargetDate}, Epic: {EpicId}", 
                    currentDraggedItem.WorkItemId, dropResult.TargetDate, epicId);
                
                await LoadRoadmapDataAsync();
            }
            else
            {
                Logger.LogError("Failed to update work item {WorkItemId}", currentDraggedItem.WorkItemId);
                Snackbar.Add($"? Failed to update Azure DevOps. Please try again.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Exception during epic drop for work item {WorkItemId}", currentDraggedItem?.WorkItemId);
            Snackbar.Add($"? Error processing drop: {ex.Message}", Severity.Error);
        }
        finally
        {
            // Clean up drag state
            currentDraggedItem = null;
            isDragging = false;
            await JSRuntime.InvokeVoidAsync("roadmapDateCalculator.hideIndicator");
            StateHasChanged();
        }
    }

    // Timeline Drop Handler (new feature)
    private async Task OnTimelineDrop(DragEventArgs e)
    {
        if (currentDraggedItem == null)
        {
            Logger.LogWarning("No dragged item found during timeline drop");
            return;
        }

        try
        {
            Logger.LogInformation("Processing timeline drop of {WorkItemId} at position ({ClientX}, {ClientY})", 
                currentDraggedItem.WorkItemId, e.ClientX, e.ClientY);

            Snackbar.Add($"Scheduling {currentDraggedItem.Title}...", Severity.Info);

            // Process drop without specific epic (schedule on timeline)
            var dropResult = await DragDropService.ProcessDropAsync(
                currentDraggedItem, 
                e.ClientX, 
                e.ClientY, 
                configuration.StartDate, 
                configuration.EndDate);

            if (!dropResult.Success)
            {
                Logger.LogWarning("Timeline drop validation failed: {ErrorMessage}", dropResult.ErrorMessage);
                Snackbar.Add($"? {dropResult.ErrorMessage}", Severity.Warning);
                if (!string.IsNullOrEmpty(dropResult.SuggestedAction))
                {
                    Snackbar.Add($"?? {dropResult.SuggestedAction}", Severity.Info);
                }
                return;
            }

            // Update work item with target date only (no parent change)
            var success = await RoadmapService.UpdateWorkItemTargetDateAsync(
                currentDraggedItem.WorkItemId, dropResult.TargetDate);

            if (success)
            {
                Snackbar.Add($"? Scheduled {currentDraggedItem.Title} for {dropResult.TargetDate:MMM dd, yyyy}", Severity.Success);
                
                Logger.LogInformation("Successfully scheduled work item {WorkItemId} for {TargetDate}", 
                    currentDraggedItem.WorkItemId, dropResult.TargetDate);
                
                await LoadRoadmapDataAsync();
            }
            else
            {
                Logger.LogError("Failed to update work item {WorkItemId} target date", currentDraggedItem.WorkItemId);
                Snackbar.Add($"? Failed to update Azure DevOps. Please try again.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Exception during timeline drop for work item {WorkItemId}", currentDraggedItem?.WorkItemId);
            Snackbar.Add($"? Error processing timeline drop: {ex.Message}", Severity.Error);
        }
        finally
        {
            // Clean up drag state
            currentDraggedItem = null;
            isDragging = false;
            await JSRuntime.InvokeVoidAsync("roadmapDateCalculator.hideIndicator");
            StateHasChanged();
        }
    }

    // High-Performance Drag Over with Pure Client-Side Visual Feedback
    private void OnTimelineDragOver(DragEventArgs e)
    {
        if (currentDraggedItem != null)
        {
            e.DataTransfer.DropEffect = "move";
            // Note: Visual feedback is now handled purely in JavaScript for performance
            // No C# interop calls during drag operations
        }
    }

    private async Task OnTimelineDragEnter(DragEventArgs e)
    {
        if (currentDraggedItem != null)
        {
            // Initialize the JavaScript calculator with timeline data for performance
            await JSRuntime.InvokeVoidAsync("roadmapDateCalculator.init", 
                "timeline-column", 
                configuration.StartDate.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"),
                configuration.EndDate.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"));
            
            await JSRuntime.InvokeVoidAsync("roadmapDateCalculator.showIndicator");
        }
    }

    private async Task OnTimelineDragLeave(DragEventArgs e)
    {
        // Hide the date indicator when dragging leaves the timeline area
        await JSRuntime.InvokeVoidAsync("roadmapDateCalculator.hideIndicator");
    }

    private void OnUnscheduledDrop(DragEventArgs e, int parentId)
    {
        // Handle drop on unscheduled items area (if needed)
    }

    private void OnTimelineItemDropped(MudItemDropInfo<RoadmapTimelineItem> dropInfo, int swimlaneId)
    {
        // This is for moving existing timeline items - keep existing logic
        Logger.LogInformation("Timeline item {WorkItemId} dropped in swimlane {SwimlaneId}", 
            dropInfo.Item?.WorkItemId, swimlaneId);
        
        if (dropInfo.Item != null)
        {
            Snackbar.Add($"Rescheduled {dropInfo.Item.Title}", Severity.Success);
        }
    }

    private void ShowWorkItemDetails(RoadmapTimelineItem item)
    {
        selectedWorkItem = item;
        selectedWorkItemTargetDate = item.TargetDate;
        showWorkItemDialog = true;
    }

    private void CloseWorkItemDialog()
    {
        showWorkItemDialog = false;
        selectedWorkItem = null;
        selectedWorkItemTargetDate = null;
    }

    private async Task SaveWorkItemChanges()
    {
        if (selectedWorkItem == null) return;

        try
        {
            var success = await RoadmapService.UpdateWorkItemTargetDateAsync(
                selectedWorkItem.WorkItemId, selectedWorkItemTargetDate);
            
            if (success)
            {
                selectedWorkItem.TargetDate = selectedWorkItemTargetDate;
                Snackbar.Add("Work item updated successfully", Severity.Success);
                CloseWorkItemDialog();
                
                // Recalculate positions
                foreach (var swimlane in swimlanes)
                {
                    foreach (var child in swimlane.Children)
                    {
                        child.TimelineItems = RoadmapService.CalculateTimelinePositions(child.TimelineItems, configuration);
                    }
                }
                StateHasChanged();
            }
            else
            {
                Snackbar.Add("Failed to update work item", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating work item {WorkItemId}", selectedWorkItem.WorkItemId);
            Snackbar.Add("Error updating work item", Severity.Error);
        }
    }

    private List<(string Label, double Width)> GetTimelineMonths()
    {
        var months = new List<(string Label, double Width)>();
        var totalDays = (configuration.EndDate - configuration.StartDate).TotalDays;
        
        var current = new DateTime(configuration.StartDate.Year, configuration.StartDate.Month, 1);
        while (current <= configuration.EndDate)
        {
            var nextMonth = current.AddMonths(1);
            var startDate = current < configuration.StartDate ? configuration.StartDate : current;
            var endDate = nextMonth > configuration.EndDate ? configuration.EndDate : nextMonth.AddDays(-1);
            var days = (endDate - startDate).TotalDays + 1;
            var width = (days / totalDays) * 100.0;
            
            months.Add((current.ToString("MMM yyyy"), width));
            current = nextMonth;
        }
        
        return months;
    }

    private List<(string Label, double Width)> GetTimelineWeeks()
    {
        var weeks = new List<(string Label, double Width)>();
        var totalDays = (configuration.EndDate - configuration.StartDate).TotalDays;
        
        var current = configuration.StartDate;
        while (current <= configuration.EndDate)
        {
            var weekEnd = current.AddDays(6);
            if (weekEnd > configuration.EndDate)
                weekEnd = configuration.EndDate;
            
            var days = (weekEnd - current).TotalDays + 1;
            var width = (days / totalDays) * 100.0;
            
            var weekLabel = configuration.TimeUnit == RoadmapTimeUnit.Week 
                ? current.ToString("MM/dd") 
                : current.Day.ToString();
            
            weeks.Add((weekLabel, width));
            current = current.AddDays(7);
        }
        
        return weeks;
    }

    private List<(double X1, double Y1, double X2, double Y2, DependencyType Type)> GetVisibleDependencies()
    {
        // This would return the calculated positions for dependency lines
        // For now, return empty list as dependency calculation would be complex
        return new List<(double, double, double, double, DependencyType)>();
    }

    private string GetDisplayTitle(string title)
    {
        return title.Length > 30 ? title.Substring(0, 27) + "..." : title;
    }
}