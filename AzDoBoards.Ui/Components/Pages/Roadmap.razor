@page "/roadmap"
@using Microsoft.AspNetCore.Components.Authorization
@using AzDoBoards.Client.Models
@using AzDoBoards.Ui.Services
@using AzDoBoards.Utility
@using AzDoBoards.Models.Roadmap
@using MudBlazor
@inject IRoadmapService RoadmapService
@inject ISnackbar Snackbar
@inject ILogger<Roadmap> Logger
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Roadmap</PageTitle>

<h1>Roadmap</h1>

<MudContainer MaxWidth="MaxWidth.False" Class="roadmap-container">
    @if (isLoading)
    {
        <MudStack Row AlignItems="AlignItems.Center" Class="my-4">
            <MudProgressCircular Indeterminate="true" Size="Size.Small" />
            <MudText Typo="Typo.body2" Class="ml-2">Loading roadmap data...</MudText>
        </MudStack>
    }
    else if (!string.IsNullOrEmpty(errorMessage))
    {
        <MudAlert Severity="Severity.Error" Class="my-4">
            @errorMessage
            <MudButton Variant="Variant.Text" Color="Color.Primary" OnClick="RefreshDataAsync" Class="ml-2">
                Try Again
            </MudButton>
        </MudAlert>
    }
    else if (swimlanes?.Any() != true && unscheduledItems?.Any() != true)
    {
        <MudAlert Severity="Severity.Info" Class="my-4">
            <MudStack>
                <MudText>
                    <MudIcon Icon="@Icons.Material.Filled.Info" Class="mr-2" />
                    No roadmap items found
                </MudText>
                <MudText Typo="Typo.body2" Class="mt-2">
                    Make sure you have configured your work item hierarchy with Roadmap audience in Settings.
                </MudText>
                <MudButton Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Settings" Href="/settings" Class="mt-2 align-self-start">
                    Settings
                </MudButton>
            </MudStack>
        </MudAlert>
    }
    else
    {
        <div class="roadmap-layout">
            <MudPaper Class="unscheduled-panel" Elevation="2">
                <MudText Typo="Typo.h6" Class="pa-3">
                    <MudIcon Icon="@Icons.Material.Filled.Schedule" Class="mr-2" />
                    Unscheduled Items (@(unscheduledItems?.Count ?? 0))
                </MudText>
                <MudDivider />
                
                <div class="unscheduled-items-scroll" ondragover="event.preventDefault();" @ondrop="@(() => HandleUnscheduleDrop())">
                    @if (unscheduledItems?.Any() == true)
                    {
                        @foreach (var item in unscheduledItems)
                        {
                            <div class="unscheduled-work-item pa-2 mb-2" style="@GetUnscheduledItemStyle(item)" draggable="true" @ondragstart="@(() => OnDragStart(item.WorkItemId))" @ondragend="@OnDragEnd">
                                <MudStack Spacing="1">
                                    <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                        <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
                                            <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(item.WorkItemType)" Size="Size.Small" />
                                            <MudText Typo="Typo.caption" Style="font-weight: 600; color: white;">@item.WorkItemId</MudText>
                                        </MudStack>
                                        <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(async () => await OpenScheduleDialog(item.WorkItemId))" Style="color: white;" />
                                    </MudStack>
                                    <MudText Typo="Typo.body2" Style="font-weight: 500; color: white;">@item.Title</MudText>
                                    @if (!string.IsNullOrEmpty(item.ParentTitle))
                                    {
                                        <MudText Typo="Typo.caption" Style="color: rgba(255,255,255,0.8);">
                                            Parent: @item.ParentTitle
                                        </MudText>
                                    }
                                    @if (!string.IsNullOrEmpty(item.AssignedTo))
                                    {
                                        <MudText Typo="Typo.caption" Style="color: rgba(255,255,255,0.8);">
                                            <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" />
                                            @item.AssignedTo
                                        </MudText>
                                    }
                                </MudStack>
                            </div>
                        }
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Success" Class="ma-3">
                            All roadmap items are scheduled!
                        </MudAlert>
                    }
                </div>
            </MudPaper>

            <div class="timeline-panel">
                <MudPaper Class="timeline-header" Elevation="2">
                    <div class="timeline-header-row">
                        <div class="timeline-controls">
                            <MudStack Row AlignItems="AlignItems.Center" Spacing="2" Class="pa-2">
                                <MudButton OnClick="@(() => ChangeTimeUnit(TimeUnit.Week))" Color="Color.Primary" Size="Size.Small" Variant="@(config.TimeUnit == TimeUnit.Week ? Variant.Filled : Variant.Outlined)">
                                    Week
                                </MudButton>
                                <MudButton OnClick="@(() => ChangeTimeUnit(TimeUnit.Month))" Color="Color.Primary" Size="Size.Small" Variant="@(config.TimeUnit == TimeUnit.Month ? Variant.Filled : Variant.Outlined)">
                                    Month
                                </MudButton>
                                <MudButton OnClick="@(() => ChangeTimeUnit(TimeUnit.Quarter))" Color="Color.Primary" Size="Size.Small" Variant="@(config.TimeUnit == TimeUnit.Quarter ? Variant.Filled : Variant.Outlined)">
                                    Quarter
                                </MudButton>
                                <MudDatePicker Label="Start" Date="config.StartDate" DateChanged="@OnStartDateChanged" Variant="Variant.Outlined" Margin="Margin.Dense" Class="date-picker-compact" />
                                <MudDatePicker Label="End"   Date="config.EndDate"   DateChanged="@OnEndDateChanged"   Variant="Variant.Outlined" Margin="Margin.Dense" Class="date-picker-compact" />
                                <MudIconButton Icon="@Icons.Material.Filled.Refresh" Color="Color.Primary" OnClick="RefreshDataAsync" Size="Size.Small" />
                            </MudStack>
                        </div>
                    </div>
                </MudPaper>

                <div class="swimlanes-scroll">
                    <div class="timeline-header-content">
                        <div class="workitems-header">
                            <MudText Typo="Typo.subtitle2" Class="pa-2" Style="font-weight: 600;">Work Items</MudText>
                        </div>
                        <div class="timeline-dates" style="@GetTimelineContentWidthStyle()">
                            @foreach (var period in GetTimelinePeriods())
                            {
                                <div class="timeline-period" style="@GetPeriodStyle(period)">
                                    <MudStack Spacing="0" Class="pa-1">
                                        <MudText Typo="Typo.caption" Style="font-weight: 600; text-align: center;">@period.Label</MudText>
                                        @if (!string.IsNullOrEmpty(period.SubLabel))
                                        {
                                            <MudText Typo="Typo.caption" Style="font-size: 0.65rem; opacity: 0.8; text-align: center;">@period.SubLabel</MudText>
                                        }
                                    </MudStack>
                                </div>
                            }
                        </div>
                    </div>

                    <div class="swimlanes-content">
                        <div class="swimlane-labels">
                            @{
                                var swimLanesList = swimlanes ?? new List<SwimLane>();
                                foreach (var swimlane in swimLanesList)
                                {
                                    @RenderSwimLaneLabel(swimlane, 0)
                                }
                            }
                        </div>
                        <div class="timeline-items-container" style="@GetTimelineContentWidthStyle()" ondragover="event.preventDefault();" @ondrop="@HandleTimelineDrop"> 
                            @foreach (var swimlane in swimLanesList)
                            {
                                @RenderSwimLaneTimeline(swimlane, 0)
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
</MudContainer>

<MudDialog @bind-Visible="scheduleDialogVisible" Options="dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.Schedule" Class="mr-2" />
            Schedule Work Item
        </MudText>
    </TitleContent>
    <DialogContent>
        @if (selectedWorkItem != null)
        {
            <MudStack Spacing="3">
                <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                    <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(selectedWorkItem.WorkItemType)" Size="Size.Small" />
                    <MudText Typo="Typo.body1">@selectedWorkItemId - <span style="font-weight: 600;">@selectedWorkItem.Title</span></MudText>
                </MudStack>
                <MudDivider />
                <MudStack Row AlignItems="AlignItems.Center" Spacing="3">
                    <MudSelect T="string" Label="State" @bind-Value="selectedWorkItemState" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomLeft" Style="min-width: 150px; max-width: 200px;">
                        @foreach (var state in availableStates)
                        {
                            <MudSelectItem T="string" Value="@state">@state</MudSelectItem>
                        }
                    </MudSelect>
                    <MudDatePicker Label="Start Date" Date="scheduleStartDate" DateChanged="@((DateTime? d) => scheduleStartDate = d)" Clearable="true" />
                    <MudDatePicker Label="Target Date" Date="scheduleTargetDate" DateChanged="@((DateTime? d) => scheduleTargetDate = d)" Clearable="true" /> @* Required="true" *@
                </MudStack>
                @if (scheduleStartDate.HasValue && scheduleTargetDate.HasValue && scheduleStartDate.Value > scheduleTargetDate.Value)
                {
                    <MudAlert Severity="Severity.Warning">Start date cannot be after target date</MudAlert>
                }
            </MudStack>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseScheduleDialog">Cancel</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="SaveWorkItem" Disabled="@(scheduleStartDate.HasValue && scheduleTargetDate.HasValue && scheduleStartDate.Value > scheduleTargetDate.Value)">
            Save Schedule
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    private bool isLoading = true;
    private string errorMessage = string.Empty;
    private Config config = new();
    private List<SwimLane>? swimlanes;
    private List<UnscheduledWorkItem>? unscheduledItems;
    private List<WorkItem>? allWorkItems;
    private string currentProcessId = string.Empty;
    private string currentProjectId = string.Empty;

    // Drag and drop state
    private int? draggedWorkItemId;
    private DateTime? dropTargetDate;

    // JavaScript interop
    private IJSObjectReference? jsModule;
    private DotNetObjectReference<Roadmap>? dotNetRef;
    private bool jsModuleInitialized = false;

    // Schedule dialog state
    private bool scheduleDialogVisible = false;
    private int selectedWorkItemId = 0;
    private WorkItem? selectedWorkItem;
    private DateTime? scheduleStartDate;
    private DateTime? scheduleTargetDate;
    private string? selectedWorkItemState;
    private List<string> availableStates = new();

    private DialogOptions dialogOptions = new() { MaxWidth = MaxWidth.Small, FullWidth = true };

    protected override async Task OnInitializedAsync()
    {
        await LoadRoadmapDataAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Wait a bit for the DOM to settle
            await Task.Delay(100);
        }
        
        if (!isLoading && !jsModuleInitialized && (swimlanes?.Any() == true || unscheduledItems?.Any() == true))
        {
            await InitializeJavaScriptModule();
        }
    }

    private async Task InitializeJavaScriptModule()
    {
        try
        {
            Logger.LogInformation("Initializing JavaScript module for drag and drop");
            
            // Import the JavaScript module
            jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./Components/Pages/Roadmap.razor.js");

            Logger.LogInformation("JavaScript module imported successfully");

            // Create .NET reference for callbacks
            dotNetRef = DotNetObjectReference.Create(this);

            // Initialize the drag and drop system with aligned start date
            var pixelsPerDay = GetPixelsPerDay();
            var alignedStartDate = GetAlignedStartDate();
            
            Logger.LogInformation("Initializing drag system with dates: {StartDate} to {EndDate}, pixels per day: {PixelsPerDay}", 
                alignedStartDate, config.EndDate, pixelsPerDay);
            
            await jsModule.InvokeVoidAsync("initialize", 
                dotNetRef, 
                alignedStartDate.ToString("yyyy-MM-dd"), 
                config.EndDate.ToString("yyyy-MM-dd"), 
                pixelsPerDay);
            
            jsModuleInitialized = true;
            Logger.LogInformation("JavaScript module initialized successfully");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing JavaScript module");
            jsModuleInitialized = false;
        }
    }

    private async Task UpdateJavaScriptConfig()
    {
        if (jsModule != null && jsModuleInitialized)
        {
            try
            {
                var pixelsPerDay = GetPixelsPerDay();
                var alignedStartDate = GetAlignedStartDate();
                
                Logger.LogInformation("Updating JS config: {StartDate} to {EndDate}, pixels: {PixelsPerDay}", 
                    alignedStartDate, config.EndDate, pixelsPerDay);
                
                await jsModule.InvokeVoidAsync("updateConfig",
                    alignedStartDate.ToString("yyyy-MM-dd"),
                    config.EndDate.ToString("yyyy-MM-dd"),
                    pixelsPerDay);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error updating JavaScript config");
            }
        }
    }

    [JSInvokable]
    public void SetDropTargetDate(string dateString)
    {
        try
        {
            if (DateTime.TryParse(dateString, out var date))
            {
                dropTargetDate = date.Date; // Normalize to date only
                Logger.LogInformation("Drop target date set to: {Date}", dropTargetDate);
            }
            else
            {
                Logger.LogWarning("Failed to parse drop target date: {DateString}", dateString);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error setting drop target date");
        }
    }

    private async Task LoadRoadmapDataAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = string.Empty;
            StateHasChanged();

            config = await RoadmapService.GetDefaultConfigurationAsync();
            (currentProcessId, currentProjectId) = await RoadmapService.GetConfigurationAsync();

            if (string.IsNullOrEmpty(currentProcessId) || string.IsNullOrEmpty(currentProjectId))
            {
                errorMessage = "Please configure your process and project in Settings first.";
                return;
            }

            allWorkItems = await RoadmapService.LoadRoadmapWorkItemsAsync(currentProjectId, currentProcessId);

            if (allWorkItems?.Count > 0)
            {
                swimlanes = await RoadmapService.BuildRoadmapSwimlanesAsync(allWorkItems, currentProcessId);
                unscheduledItems = await RoadmapService.GetUnscheduledWorkItemsAsync(allWorkItems, currentProcessId);
            }
            else
            {
                swimlanes = new List<SwimLane>();
                unscheduledItems = new List<UnscheduledWorkItem>();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading roadmap data");
            errorMessage = $"Error loading roadmap: {ex.Message}";
            Snackbar.Add(errorMessage, Severity.Error);
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task RefreshDataAsync()
    {
        await LoadRoadmapDataAsync();
        
        // Reinitialize JavaScript module after data refresh
        if (jsModuleInitialized)
        {
            jsModuleInitialized = false;
            await Task.Delay(100); // Wait for render
            await InitializeJavaScriptModule();
        }
        
        Snackbar.Add("Roadmap refreshed", Severity.Success);
    }

    private async Task ChangeTimeUnit(TimeUnit newUnit)
    {
        config.TimeUnit = newUnit;
        await RoadmapService.SaveConfigurationAsync(config);
        await UpdateJavaScriptConfig();
        StateHasChanged();
    }

    private async Task OnStartDateChanged(DateTime? newDate)
    {
        if (!newDate.HasValue) return;

        config.StartDate = newDate.Value;
        await RoadmapService.SaveConfigurationAsync(config);
        await UpdateJavaScriptConfig();
        StateHasChanged();
    }

    private async Task OnEndDateChanged(DateTime? newDate)
    {
        if (!newDate.HasValue) return;

        config.EndDate = newDate.Value;
        await RoadmapService.SaveConfigurationAsync(config);
        await UpdateJavaScriptConfig();
        StateHasChanged();
    }

    // Drag and Drop handlers
    private void OnDragStart(int workItemId)
    {
        draggedWorkItemId = workItemId;
        Logger.LogInformation("Drag started for work item {WorkItemId}", workItemId);
    }

    private void OnDragEnd()
    {
        Logger.LogInformation("Drag ended");
        draggedWorkItemId = null;
        dropTargetDate = null;
    }

    private async Task HandleTimelineDrop()
    {
        Logger.LogInformation("HandleTimelineDrop called. DraggedItemId: {ItemId}, DropTargetDate: {Date}", 
            draggedWorkItemId, dropTargetDate);
        
        if (!draggedWorkItemId.HasValue)
        {
            Logger.LogWarning("Drop called but no dragged work item ID");
            OnDragEnd();
            return;
        }

        if (!dropTargetDate.HasValue)
        {
            Logger.LogWarning("Drop called but no drop target date set");
            OnDragEnd();
            return;
        }

        try
        {
            Logger.LogInformation("Updating work item {WorkItemId} with target date {TargetDate}", 
                draggedWorkItemId.Value, dropTargetDate.Value);
            
            var success = await UpdateWorkItemDatesAsync(draggedWorkItemId.Value, null, dropTargetDate.Value);
            
            if (success)
            {
                Logger.LogInformation("Successfully updated work item {WorkItemId}", draggedWorkItemId.Value);
                await LoadRoadmapDataAsync();
                Snackbar.Add($"Work item {draggedWorkItemId.Value} scheduled to {dropTargetDate.Value:M/d/yyyy}", Severity.Success);
            }
            else
            {
                Logger.LogError("Failed to update work item {WorkItemId}", draggedWorkItemId.Value);
                Snackbar.Add($"Failed to update work item {draggedWorkItemId.Value}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in timeline drop handler for work item {WorkItemId}", draggedWorkItemId);
            Snackbar.Add($"Error updating work item: {ex.Message}", Severity.Error);
        }
        finally
        {
            OnDragEnd();
        }
    }

    private async Task HandleUnscheduleDrop()
    {
        Logger.LogInformation("HandleUnscheduleDrop called. DraggedItemId: {ItemId}", draggedWorkItemId);
        
        if (!draggedWorkItemId.HasValue)
        {
            OnDragEnd();
            return;
        }

        try
        {
            Logger.LogInformation("Clearing target date for work item {WorkItemId}", draggedWorkItemId.Value);
            
            var success = await UpdateWorkItemDatesAsync(draggedWorkItemId.Value, null, null);
            
            if (success)
            {
                await LoadRoadmapDataAsync();
                Snackbar.Add($"Work item {draggedWorkItemId.Value} unscheduled successfully", Severity.Success);
            }
            else
            {
                Snackbar.Add($"Failed to update work item {draggedWorkItemId.Value}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in unschedule drop handler");
            Snackbar.Add($"Error updating work item: {ex.Message}", Severity.Error);
        }
        finally
        {
            OnDragEnd();
        }
    }

    // Schedule Dialog handlers
    private async Task OpenScheduleDialog(int workItemId)
    {
        selectedWorkItemId = workItemId;
        selectedWorkItem = allWorkItems?.FirstOrDefault(wi => wi.Id == workItemId);

        if (selectedWorkItem != null)
        {
            scheduleStartDate = selectedWorkItem.Fields.TryGetValue("Microsoft.VSTS.Scheduling.StartDate", out var startDateObj) && startDateObj is DateTime startDate
                ? startDate
                : null;
            scheduleTargetDate = selectedWorkItem.TargetDate;
            selectedWorkItemState = selectedWorkItem.State;
            
            // Load available states for the work item type
            availableStates = await RoadmapService.GetAvailableStatesForWorkItemTypeAsync(selectedWorkItem.WorkItemType, currentProcessId);

            scheduleDialogVisible = true;
        }
    }

    private void CloseScheduleDialog()
    {
        scheduleDialogVisible = false;
        selectedWorkItemId = 0;
        selectedWorkItem = null;
        scheduleStartDate = null;
        scheduleTargetDate = null;
        selectedWorkItemState = null;
        availableStates.Clear();
    }

    private async Task SaveWorkItem()
    {
        if (selectedWorkItemId <= 0 || selectedWorkItem == null) return;

        try
        {
            var updates = new List<string>();

            // Check what fields have changed
            var currentStartDate = selectedWorkItem.Fields.TryGetValue("Microsoft.VSTS.Scheduling.StartDate", out var startDateObj) && startDateObj is DateTime sd
                ? (DateTime?)sd
                : null;
            
            var startDateChanged = scheduleStartDate != currentStartDate;
            var targetDateChanged = scheduleTargetDate != selectedWorkItem.TargetDate;
            var stateChanged = !string.IsNullOrEmpty(selectedWorkItemState) && selectedWorkItemState != selectedWorkItem.State;

            // If nothing changed, just close the dialog
            if (!startDateChanged && !targetDateChanged && !stateChanged)
            {
                CloseScheduleDialog();
                return;
            }

            // Build update messages
            if (targetDateChanged)
            {
                var action = scheduleTargetDate.HasValue ? "scheduled" : "unscheduled";
                updates.Add(action);
            }

            if (startDateChanged && scheduleStartDate.HasValue)
            {
                updates.Add($"start date set to {scheduleStartDate.Value:M/d/yyyy}");
            }
            else if (startDateChanged && !scheduleStartDate.HasValue)
            {
                updates.Add("start date cleared");
            }

            if (stateChanged)
            {
                updates.Add($"state changed to {selectedWorkItemState}");
            }

            // Make a single API call to update all changed fields
            var success = await RoadmapService.UpdateWorkItemFieldsAsync(
                selectedWorkItemId,
                scheduleStartDate,
                scheduleTargetDate,
                stateChanged ? selectedWorkItemState : null,
                updateStartDate: startDateChanged,
                updateTargetDate: targetDateChanged
            );

            if (success)
            {
                // Update local data
                var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == selectedWorkItemId);
                if (workItem != null)
                {
                    if (targetDateChanged)
                        workItem.TargetDate = scheduleTargetDate;
                    
                    if (startDateChanged)
                    {
                        if (scheduleStartDate.HasValue)
                            workItem.Fields["Microsoft.VSTS.Scheduling.StartDate"] = scheduleStartDate.Value;
                        else
                            workItem.Fields.Remove("Microsoft.VSTS.Scheduling.StartDate");
                    }
                    
                    if (stateChanged && !string.IsNullOrEmpty(selectedWorkItemState))
                        workItem.State = selectedWorkItemState;
                }

                // Refresh the roadmap data to reflect changes
                await LoadRoadmapDataAsync();
                
                var message = $"Work item {selectedWorkItemId} updated: {string.Join(", ", updates)}";
                Snackbar.Add(message, Severity.Success);
            }
            else
            {
                Snackbar.Add($"Failed to update work item {selectedWorkItemId}", Severity.Error);
                return;
            }
            
            CloseScheduleDialog();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving work item {WorkItemId}", selectedWorkItemId);
            Snackbar.Add($"Error saving work item: {ex.Message}", Severity.Error);
        }
    }

    private async Task<bool> UpdateWorkItemDatesAsync(int workItemId, DateTime? startDate, DateTime? targetDate)
    {
        try
        {
            var success = await RoadmapService.UpdateWorkItemDatesAsync(workItemId, startDate, targetDate);
            
            if (success)
            {
                // Update local data
                var workItem = allWorkItems?.FirstOrDefault(wi => wi.Id == workItemId);
                if (workItem != null)
                {
                    workItem.TargetDate = targetDate;
                    if (startDate.HasValue)
                        workItem.Fields["Microsoft.VSTS.Scheduling.StartDate"] = startDate.Value;
                    else
                        workItem.Fields.Remove("Microsoft.VSTS.Scheduling.StartDate");
                }
            }

            return success;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating work item {WorkItemId} dates", workItemId);
            return false;
        }
    }

    // Helper methods - Consolidated repeated logic
    private int GetPixelsPerDay() => config.TimeUnit switch
    {
        TimeUnit.Week => 10,
        TimeUnit.Month => 3,
        TimeUnit.Quarter => 1,
        _ => 3
    };

    private string GetColorWithFallback(string? color) => !string.IsNullOrEmpty(color) ? color : "#6C757D";
    private string GetUnscheduledItemStyle(UnscheduledWorkItem item) => $"background-color: {GetColorWithFallback(item.Color)}; border-radius: 4px; cursor: move;";
    private string GetPeriodStyle(TimelinePeriod period) => $"width: {period.Width}px; min-width: {period.Width}px;";
    private bool HasChildren(SwimLane swimlane) => swimlane.Children?.Any() == true;

    private string GetTimelineContentWidthStyle()
    {
        var periods = GetTimelinePeriods();
        var totalWidth = periods.Sum(p => p.Width);
        return $"min-width: {totalWidth}px; width: {totalWidth}px;";
    }

    private List<TimelinePeriod> GetTimelinePeriods()
    {
        var periods = new List<TimelinePeriod>();
        var pixelsPerDay = GetPixelsPerDay();

        if (config.TimeUnit == TimeUnit.Week)
        {
            var current = config.StartDate;
            while (current <= config.EndDate)
            {
                var weekStart = current;
                var weekEnd = current.AddDays(6);
                if (weekEnd > config.EndDate) weekEnd = config.EndDate;
                
                var weekNumber = System.Globalization.ISOWeek.GetWeekOfYear(weekStart);
                var daysInWeek = (weekEnd - weekStart).Days + 1;
                
                periods.Add(new TimelinePeriod
                {
                    Label = $"Week {weekNumber}",
                    SubLabel = $"{weekStart:MMM d} - {weekEnd:MMM d}",
                    Width = daysInWeek * pixelsPerDay,
                    StartDate = weekStart,
                    EndDate = weekEnd
                });
                current = weekEnd.AddDays(1);
            }
        }
        else if (config.TimeUnit == TimeUnit.Month)
        {
            var current = GetAlignedStartDate();
            while (current <= config.EndDate)
            {
                var daysInMonth = DateTime.DaysInMonth(current.Year, current.Month);
                periods.Add(new TimelinePeriod
                {
                    Label = current.ToString("MMM yyyy"),
                    SubLabel = $"{daysInMonth} days",
                    Width = daysInMonth * pixelsPerDay,
                    StartDate = current,
                    EndDate = current.AddMonths(1).AddDays(-1)
                });
                current = current.AddMonths(1);
            }
        }
        else if (config.TimeUnit == TimeUnit.Quarter)
        {
            var current = GetAlignedStartDate();
            while (current <= config.EndDate)
            {
                var quarter = (current.Month - 1) / 3 + 1;
                var endOfQuarter = current.AddMonths(3).AddDays(-1);
                var daysInQuarter = (endOfQuarter - current).Days + 1;
                
                periods.Add(new TimelinePeriod
                {
                    Label = $"Q{quarter} {current.Year}",
                    SubLabel = $"{current:MMM} - {endOfQuarter:MMM}",
                    Width = daysInQuarter * pixelsPerDay,
                    StartDate = current,
                    EndDate = endOfQuarter
                });
                current = current.AddMonths(3);
            }
        }

        return periods;
    }

    private class TimelinePeriod
    {
        public string Label { get; set; } = string.Empty;
        public string SubLabel { get; set; } = string.Empty;
        public double Width { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime EndDate { get; set; }
    }

    private string GetDateRangeDisplay(TimelineItem item)
    {
        return $"{item.StartDate:M/d/yyyy} - {item.TargetDate.Value:M/d/yyyy}".Trim();
    }

    private RenderFragment RenderSwimLaneLabel(SwimLane swimlane, int level) => __builder =>
    {
        var indentStyle = $"padding-left: {level * 20 + 8}px;";
        var backgroundColor = GetColorWithFallback(swimlane.Color);
        
        <div class="timeline-row" style="@indentStyle">
            <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
                @if (HasChildren(swimlane))
                {
                    <MudIconButton Icon="@(swimlane.IsCollapsed ? Icons.Material.Filled.ChevronRight : Icons.Material.Filled.ExpandMore)" Size="Size.Small" OnClick="@(() => ToggleCollapse(swimlane))" />
                }
                else
                {
                    <div style="width: 24px;"></div>
                }
                <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(swimlane.WorkItemType)" Size="Size.Small" Style="@($"color: {backgroundColor};")" />
                <MudText Typo="Typo.body2" Style="font-weight: 500;">@swimlane.WorkItemId - @swimlane.Title</MudText>
            </MudStack>
        </div>

        @if (!swimlane.IsCollapsed && HasChildren(swimlane))
        {
            @foreach (var child in swimlane.Children!)
            {
                @RenderSwimLaneLabel(child, level + 1)
            }
        }
    };

    private RenderFragment RenderSwimLaneTimeline(SwimLane swimlane, int level) => __builder =>
    {
        <div class="timeline-row">
            @if (swimlane.TimelineItems?.Any() == true)
            {
                @foreach (var item in swimlane.TimelineItems.Where(ti => ti.TargetDate.HasValue))
                {
                    if (item.TargetDate == null) continue;

                    var position = CalculateItemPosition(item);
                    var itemStyle = $"left: {position.Left}px; width: {position.Width}px; background-color: {item.Color};";
                    var itemClass = draggedWorkItemId == item.WorkItemId ? "timeline-item dragging" : "timeline-item";
                    var dateRange = GetDateRangeDisplay(item);
                    
                    <div class="@itemClass" style="@itemStyle" title="@($"{item.Title} - {dateRange}")" draggable="true" @ondragstart="@(() => OnDragStart(item.WorkItemId))" @ondragend="@OnDragEnd" @onclick="@(async () => await OpenScheduleDialog(item.WorkItemId))">
                        <MudStack Spacing="0" Style="padding: 2px 4px;">
                            <MudText Typo="Typo.caption" Style="color: white; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 500;">
                                @item.WorkItemId - @item.Title
                            </MudText>
                            <MudText Typo="Typo.caption" Style="color: rgba(255,255,255,0.9); font-size: 0.65rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                @dateRange
                            </MudText>
                        </MudStack>
                    </div>
                }
            }
        </div>

        @if (!swimlane.IsCollapsed && HasChildren(swimlane))
        {
            @foreach (var child in swimlane.Children!)
            {
                @RenderSwimLaneTimeline(child, level + 1)
            }
        }
    };

    private void ToggleCollapse(SwimLane swimlane)
    {
        swimlane.IsCollapsed = !swimlane.IsCollapsed;
        StateHasChanged();
    }

    private (double Left, double Width) CalculateItemPosition(TimelineItem item)
    {
        if (!item.TargetDate.HasValue) return (0, 0);

        var pixelsPerDay = GetPixelsPerDay();
        var startDate = item.StartDate ?? item.TargetDate.Value.AddDays(-90);
        var endDate = item.TargetDate.Value;
        var timelineStart = GetAlignedStartDate();
        
        var daysFromStart = (startDate - timelineStart).TotalDays;
        var duration = (endDate - startDate).TotalDays;

        var left = Math.Max(0, daysFromStart * pixelsPerDay);
        var width = Math.Max(20, duration * pixelsPerDay);

        return (left, width);
    }
    
    private DateTime GetAlignedStartDate()
    {
        return config.TimeUnit switch
        {
            TimeUnit.Week => config.StartDate,
            TimeUnit.Month => new DateTime(config.StartDate.Year, config.StartDate.Month, 1),
            TimeUnit.Quarter => new DateTime(config.StartDate.Year, ((config.StartDate.Month - 1) / 3) * 3 + 1, 1),
            _ => config.StartDate
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (jsModule != null)
        {
            try
            {
                await jsModule.InvokeVoidAsync("dispose");
                await jsModule.DisposeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing JavaScript module");
            }
        }

        dotNetRef?.Dispose();
    }
}
