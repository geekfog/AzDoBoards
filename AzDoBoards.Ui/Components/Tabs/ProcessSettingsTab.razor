@using System.Text.Json
@using AzDoBoards.Client
@using AzDoBoards.Client.Models
@using AzDoBoards.Client.Services
@using AzDoBoards.Data.Abstractions
@using AzDoBoards.Utility
@using AzDoBoards.Utility.Models
@using Microsoft.AspNetCore.Components.Authorization
@using MudBlazor
@inject ISettingsRepository SettingsRepository
@inject IServiceProvider ServiceProvider
@inject ISnackbar Snackbar
@inject ILogger<ProcessSettingsTab> Logger

@if (isInitialLoading)
{
    <MudStack Row AlignItems="AlignItems.Center" Class="mb-4">
        <MudProgressCircular Indeterminate="true" Size="Size.Small" />
        <MudText Typo="Typo.body2" Class="ml-2">Loading process configuration...</MudText>
    </MudStack>
}
else
{
    <MudGrid>
        <!-- Process Configuration -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardContent>
                    <MudText Typo="Typo.h6" GutterBottom="true">Process Configuration</MudText>

                    @if (availableProcesses?.Any() == true)
                    {
                        <MudStack Row AlignItems="AlignItems.End" Spacing="2" Class="mb-3">
                            <MudSelect T="string" @bind-Value="selectedProcessId" @bind-Value:after="OnProcessSelectionChanged" Label="Selected Process" Placeholder="Choose a process" Class="flex-grow-1">
                                @foreach (var process in availableProcesses.OrderBy(p => p.Name))
                                {
                                    <MudSelectItem T="string" Value="@process.Id.ToString()">
                                        @process.Name (@(process.IsSystemProcess ? "System" : process.ParentProcessName))
                                    </MudSelectItem>
                                }
                            </MudSelect>

                            @if (isLoadingProjects && (availableProjects == null || !availableProjects.Any()))
                            {
                                <MudStack Row AlignItems="AlignItems.Center" Class="flex-grow-1">
                                    <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                                    <MudText Typo="Typo.body2" Class="ml-2">Loading projects...</MudText>
                                </MudStack>
                            }
                            else if (availableProjects?.Any() == true)
                            {
                                <MudSelect T="string" @bind-Value="selectedProjectId" @bind-Value:after="OnProjectSelectionChanged" Label="Selected Project" Placeholder="Choose a project" Class="flex-grow-1">
                                    @foreach (var project in availableProjects.OrderBy(p => p.Name))
                                    {
                                        <MudSelectItem T="string" Value="@project.Id.ToString()">
                                            @project.Name
                                        </MudSelectItem>
                                    }
                                </MudSelect>
                            }
                            else if (!string.IsNullOrEmpty(selectedProcessId) && !isLoadingProjects)
                            {
                                <MudText Typo="Typo.body2" Color="Color.Warning" Class="flex-grow-1">No projects available</MudText>
                            }

                            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveDefaultConfigurationAsync" Disabled="!AllowDefaultConfigurationSave">
                                Set as Default
                            </MudButton>
                        </MudStack>

                        @if (isLoadingWorkItemTypes && (availableWorkItemTypes == null || !availableWorkItemTypes.Any()))
                        {
                            <MudStack Row AlignItems="AlignItems.Center" Class="mb-3">
                                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                                <MudText Typo="Typo.body2" Class="ml-2">Loading work item types...</MudText>
                            </MudStack>
                        }

                        @if (string.IsNullOrEmpty(selectedProcessId) || string.IsNullOrEmpty(selectedProjectId))
                        {
                            <MudAlert Severity="Severity.Info" Class="mt-3">
                                Select both a process and project to set as default configuration.
                            </MudAlert>
                        }
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Warning">No processes available. Please check your connection.</MudAlert>
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>

        <!-- Work Item Hierarchy Configuration -->
        @if (!string.IsNullOrEmpty(selectedProcessId) && availableWorkItemTypes?.Any() == true)
        {
            <MudItem xs="12">
                <MudCard>
                    <MudCardContent>
                        <MudText Typo="Typo.h6" Class="mb-3">Work Item Hierarchy Configuration - @GetProcessName(selectedProcessId)</MudText>

                        <!-- Single Drop Container for all items -->
                        <MudDropContainer T="WorkItemTypeSummary" Items="@availableWorkItemTypes" ItemsSelector="@GetItemsForDropzone" ItemDropped="OnItemDropped" Class="hierarchy-drop-container">
                            <ChildContent>
                                <MudGrid>
                                    <!-- Unassigned Work Item Types -->
                                    <MudItem xs="12" md="4">
                                        <MudPaper Class="pa-4 unassigned-panel" Style="min-height: 500px;">
                                            <MudText Typo="Typo.subtitle1" GutterBottom="true">
                                                <MudIcon Icon="@Icons.Material.Filled.Inventory" Class="mr-2" />
                                                Unassigned Work Items (@(unassignedWorkItems?.Count ?? 0))
                                            </MudText>

                                            <MudDropZone T="WorkItemTypeSummary" Identifier="unassigned" Class="pa-2 drop-zone-content drop-zone-unassigned">
                                                @if (unassignedWorkItems?.Any() == false)
                                                {
                                                    <MudAlert Severity="Severity.Success">
                                                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Class="mr-2" />
                                                        All work item types are assigned to hierarchy
                                                    </MudAlert>
                                                }
                                            </MudDropZone>
                                        </MudPaper>
                                    </MudItem>

                                    <!-- Hierarchy Builder -->
                                    <MudItem xs="12" md="8">
                                        <MudPaper Class="pa-4 hierarchy-panel" Style="min-height: 500px;">
                                            <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-3">
                                                <MudText Typo="Typo.subtitle1">
                                                    <MudIcon Icon="@Icons.Material.Filled.AccountTree" Class="mr-2" />
                                                    Work Item Hierarchy (@workItemHierarchy.Count levels)
                                                </MudText>
                                                <MudStack Row>
                                                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="SaveHierarchyAsync" Disabled="!hasHierarchyChanges">
                                                        Save Hierarchy
                                                    </MudButton>
                                                    <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" OnClick="ClearHierarchy">
                                                        Clear All
                                                    </MudButton>
                                                </MudStack>
                                            </MudStack>

                                            @if (workItemHierarchy?.Any() == true)
                                            {
                                                <MudStack>
                                                    @for (int i = 0; i < workItemHierarchy.Count; i++)
                                                    {
                                                        var level = i;
                                                        var levelItems = workItemHierarchy[level];

                                                        <MudPaper Class="level-container" Style="@($"border-left: 4px solid {WorkItemHelper.GetLevelColor(level)}; margin-bottom: 8px;")">
                                                            <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="level-header">
                                                                <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                                                                    <MudText Typo="Typo.subtitle2" Class="level-title">
                                                                        Level @(level + 1) (@levelItems.Count items)
                                                                    </MudText>
                                                                    
                                                                    <!-- Audience Checkboxes -->
                                                                    <MudStack Row AlignItems="AlignItems.Center" Spacing="1" Class="ml-4">
                                                                        <MudCheckBox T="bool" 
                                                                                   Value="@IsAudienceSelected(level, "Roadmap")" 
                                                                                   ValueChanged="@(value => OnAudienceChanged(level, "Roadmap", value))"
                                                                                   Label="Roadmap" 
                                                                                   Color="Color.Primary" 
                                                                                   Size="Size.Small" />
                                                                        <MudCheckBox T="bool" 
                                                                                   Value="@IsAudienceSelected(level, "Planning")" 
                                                                                   ValueChanged="@(value => OnAudienceChanged(level, "Planning", value))"
                                                                                   Label="Planning" 
                                                                                   Color="Color.Secondary" 
                                                                                   Size="Size.Small" />
                                                                        <MudCheckBox T="bool" 
                                                                                   Value="@IsAudienceSelected(level, "Building")" 
                                                                                   ValueChanged="@(value => OnAudienceChanged(level, "Building", value))"
                                                                                   Label="Building" 
                                                                                   Color="Color.Tertiary" 
                                                                                   Size="Size.Small" />
                                                                    </MudStack>
                                                                </MudStack>
                                                                
                                                                <MudStack Row Spacing="1">
                                                                    <MudTooltip Text="Move level up">
                                                                        <MudIconButton Icon="@Icons.Material.Filled.MoveUp" Size="Size.Small" OnClick="@(() => MoveLevelUp(level))" Disabled="level == 0" Variant="@(level == 0 ? Variant.Outlined : Variant.Filled)" Color="@(level == 0 ? Color.Default : Color.Info)" />
                                                                    </MudTooltip>
                                                                    <MudTooltip Text="Move level down">
                                                                        <MudIconButton Icon="@Icons.Material.Filled.MoveDown" Size="Size.Small" OnClick="@(() => MoveLevelDown(level))" Disabled="level == workItemHierarchy.Count - 1" Variant="@(level == workItemHierarchy.Count - 1 ? Variant.Outlined : Variant.Filled)" Color="@(level == workItemHierarchy.Count - 1 ? Color.Default : Color.Info)" />
                                                                    </MudTooltip>
                                                                    <MudTooltip Text="Insert level above">
                                                                        <MudIconButton Icon="@IconSvg.IconAddRowAbove" Size="Size.Small" OnClick="@(() => AddLevelAbove(level))" Variant="Variant.Filled" Color="Color.Tertiary" />
                                                                    </MudTooltip>
                                                                    <MudTooltip Text="Insert level below">
                                                                        <MudIconButton Icon="@IconSvg.IconAddRowBelow" Size="Size.Small" OnClick="@(() => AddLevelBelow(level))" Variant="Variant.Filled" Color="Color.Tertiary" />
                                                                    </MudTooltip>
                                                                    @if (workItemHierarchy.Count > 1)
                                                                    {
                                                                        <MudTooltip Text="Remove level">
                                                                            <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" OnClick="@(() => RemoveLevel(level))" Variant="Variant.Filled" Color="Color.Error" />
                                                                        </MudTooltip>
                                                                    }
                                                                </MudStack>
                                                            </MudStack>

                                                            <MudDropZone T="WorkItemTypeSummary" Identifier="@($"level-{level}")" Class="level-drop-zone">
                                                                @if (!levelItems.Any())
                                                                {
                                                                    <MudText Typo="Typo.body2" Class="empty-level-text">
                                                                        Drop work items here or click items from the left panel
                                                                    </MudText>
                                                                }
                                                            </MudDropZone>
                                                        </MudPaper>
                                                    }
                                                </MudStack>
                                            }
                                            else
                                            {
                                                <MudAlert Severity="Severity.Info" Class="getting-started-alert">
                                                    <MudStack>
                                                        <MudText>
                                                            <MudIcon Icon="@Icons.Material.Filled.Info" Class="mr-2" />
                                                            Hierarchy will be created automatically when you assign work items.
                                                        </MudText>
                                                        <MudText Typo="Typo.body2" Class="mt-2">
                                                            Click on work items from the left panel to get started.
                                                        </MudText>
                                                    </MudStack>
                                                </MudAlert>
                                            }
                                        </MudPaper>
                                    </MudItem>
                                </MudGrid>
                            </ChildContent>
                            <ItemRenderer>
                                @{
                                    var level = GetLevelForItem(context);
                                    var isInHierarchy = level >= 0;
                                }
                                <div class="draggable-item-wrapper @(isInHierarchy ? "hierarchy-chip" : "clickable-chip")" style="@GetWorkItemChipStyle(context, isInHierarchy)">
                                    <div class="d-flex align-center pa-2" @onclick="@(() => { if (!isInHierarchy) AddToHierarchy(context); })">
                                        <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(context.Name)" Size="Size.Small" Class="mr-2" />
                                        <MudText Class="flex-grow-1">@context.Name</MudText>
                                        @if (isInHierarchy)
                                        {
                                            <MudTooltip Text="Remove from hierarchy">
                                                <MudIconButton Icon="@Icons.Material.Filled.Cancel" Size="Size.Small" OnClick="@(() => RemoveFromHierarchy(context, level))" Variant="Variant.Filled" Color="Color.Surface" Class="work-item-remove-button" />
                                            </MudTooltip>
                                        }
                                        <MudIcon Icon="@Icons.Material.Filled.DragIndicator" Class="drag-handle" />
                                    </div>
                                </div>
                            </ItemRenderer>
                        </MudDropContainer>
                    </MudCardContent>
                </MudCard>
            </MudItem>
        }
    </MudGrid>
}

@code {
    [Parameter] public EventCallback<string> OnStatusMessage { get; set; }

    private bool isInitialized = false;
    private bool isInitialLoading = false;
    private bool isLoadingWorkItemTypes = false;
    private bool isLoadingProjects = false;
    private bool hasHierarchyChanges = false;
    private string savedProcessId = string.Empty;
    private string savedProjectId = string.Empty;

    private string selectedProcessId = string.Empty;
    private string selectedProjectId = string.Empty;
    private List<ProcessSummary>? availableProcesses;
    private List<ProjectSummary>? availableProjects;
    private List<WorkItemTypeSummary>? availableWorkItemTypes;
    private List<WorkItemTypeSummary>? unassignedWorkItems;
    private List<List<WorkItemTypeSummary>> workItemHierarchy = new();
    private List<List<string>> hierarchyAudiences = new(); // Track audiences for each level

    private bool AllowDefaultConfigurationSave => !string.IsNullOrEmpty(selectedProcessId) && !string.IsNullOrEmpty(selectedProjectId) && (selectedProcessId != savedProcessId || selectedProjectId != savedProjectId);

    public async Task InitializeAsync()
    {
        if (isInitialized) return;

        isInitialLoading = true;
        StateHasChanged();

        try
        {
            // Load settings first to get saved IDs
            await LoadSavedSettingsAsync();

            // Load processes concurrently with other data that doesn't depend on it
            var processesTask = LoadProcessesAsync();
            
            // If we have a saved process ID, start loading dependent data concurrently
            var workItemTypesTask = !string.IsNullOrEmpty(selectedProcessId) ? LoadWorkItemTypesAsync() : Task.CompletedTask;
            var projectsTask = !string.IsNullOrEmpty(selectedProcessId) ? LoadProjectsAsync() : Task.CompletedTask;

            // Wait for all initial loads to complete
            await Task.WhenAll(processesTask, workItemTypesTask, projectsTask);

            // Load hierarchy after work item types are available
            if (availableWorkItemTypes != null)
            {
                await LoadWorkItemHierarchyAsync();
                UpdateUnassignedWorkItems();
            }
        }
        finally
        {
            isInitialLoading = false;
            isInitialized = true;
            StateHasChanged();
        }
    }

    private async Task LoadSavedSettingsAsync()
    {
        try
        {
            savedProcessId = await SettingsRepository.GetOrCreateAsync("process", string.Empty);
            selectedProcessId = savedProcessId;

            if (!string.IsNullOrEmpty(savedProcessId))
            {
                var projectKey = $"project-{savedProcessId}";
                savedProjectId = await SettingsRepository.GetOrCreateAsync(projectKey, string.Empty);
                selectedProjectId = savedProjectId;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading saved settings");
            Snackbar.Add("Error loading saved settings", Severity.Error);
        }
    }

    private async Task LoadProcessesAsync()
    {
        try
        {
            if (!isInitialLoading) StateHasChanged();

            var authProvider = ServiceProvider.GetRequiredService<AuthenticationStateProvider>();
            var authState = await authProvider.GetAuthenticationStateAsync();

            if (!authState.User.Identity?.IsAuthenticated ?? false)
            {
                await OnStatusMessage.InvokeAsync("Please authenticate to load processes.");
                return;
            }

            var processClient = ServiceProvider.GetRequiredService<ProcessServices>();
            availableProcesses = await processClient.GetProcessesAsync();

            await OnStatusMessage.InvokeAsync($"Loaded {availableProcesses.Count} processes");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading processes");
            await OnStatusMessage.InvokeAsync($"Error loading processes: {ex.Message}");
        }
        finally
        {
            if (!isInitialLoading) StateHasChanged();
        }
    }

    private async Task LoadProjectsAsync()
    {
        if (string.IsNullOrEmpty(selectedProcessId)) return;

        try
        {
            isLoadingProjects = true;
            if (!isInitialLoading) StateHasChanged();

            var authProvider = ServiceProvider.GetRequiredService<AuthenticationStateProvider>();
            var authState = await authProvider.GetAuthenticationStateAsync();

            if (!authState.User.Identity?.IsAuthenticated ?? false)
            {
                await OnStatusMessage.InvokeAsync("Please authenticate to load projects.");
                return;
            }

            var projectsClient = ServiceProvider.GetRequiredService<ProjectServices>();

            if (Guid.TryParse(selectedProcessId, out var processId))
            {
                availableProjects = await projectsClient.GetProjectInfoAsync(processId);

                // Auto-select first project if none is selected
                if (string.IsNullOrEmpty(selectedProjectId) && availableProjects?.Any() == true)
                    selectedProjectId = availableProjects[0].Id.ToString();

                await OnStatusMessage.InvokeAsync($"Loaded {availableProjects?.Count ?? 0} projects for the selected process");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading projects");
            await OnStatusMessage.InvokeAsync($"Error loading projects: {ex.Message}");
            availableProjects = null;
        }
        finally
        {
            isLoadingProjects = false;
            if (!isInitialLoading) StateHasChanged();
        }
    }

    private async Task LoadWorkItemTypesAsync()
    {
        if (string.IsNullOrEmpty(selectedProcessId) || !Guid.TryParse(selectedProcessId, out var processId))
            return;

        try
        {
            isLoadingWorkItemTypes = true;
            if (!isInitialLoading) StateHasChanged();

            var processClient = ServiceProvider.GetRequiredService<ProcessServices>();
            availableWorkItemTypes = await processClient.GetWorkItemTypesForProcessAsync(processId);

            await OnStatusMessage.InvokeAsync($"Loaded {availableWorkItemTypes.Count} work item types");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading work item types");
            await OnStatusMessage.InvokeAsync($"Error loading work item types: {ex.Message}");
        }
        finally
        {
            isLoadingWorkItemTypes = false;
            if (!isInitialLoading) StateHasChanged();
        }
    }

    private async Task OnProcessSelectionChanged()
    {
        if (!string.IsNullOrEmpty(selectedProcessId))
        {
            // Clear dependent data
            availableWorkItemTypes = null;
            workItemHierarchy.Clear();
            hierarchyAudiences.Clear();
            unassignedWorkItems = null;
            hasHierarchyChanges = false;
            availableProjects = null;
            selectedProjectId = string.Empty;

            StateHasChanged();

            // Load work item types and projects concurrently
            var workItemTypesTask = LoadWorkItemTypesAsync();
            var projectsTask = LoadProjectsAsync();

            await Task.WhenAll(workItemTypesTask, projectsTask);

            // Load hierarchy after work item types are available
            if (availableWorkItemTypes != null)
            {
                await LoadWorkItemHierarchyAsync();
                UpdateUnassignedWorkItems();
            }

            StateHasChanged();
        }
    }

    private void OnProjectSelectionChanged()
    {
        StateHasChanged();
    }

    private async Task SaveDefaultConfigurationAsync()
    {
        try
        {
            if (string.IsNullOrEmpty(selectedProcessId) || string.IsNullOrEmpty(selectedProjectId))
            {
                Snackbar.Add("Both process and project must be selected", Severity.Warning);
                return;
            }

            var selectedProcess = availableProcesses?.FirstOrDefault(p => p.Id.ToString() == selectedProcessId);
            var selectedProject = availableProjects?.FirstOrDefault(p => p.Id.ToString() == selectedProjectId);
            var processName = selectedProcess?.Name ?? "Unknown Process";
            var projectName = selectedProject?.Name ?? "Unknown Project";

            await SettingsRepository.SetAsync("process", selectedProcessId, $"Process: {processName}");
            savedProcessId = selectedProcessId;

            var projectKey = $"project-{savedProcessId}";
            await SettingsRepository.SetAsync(projectKey, selectedProjectId, $"Process: {processName}, Project: {projectName}");
            savedProjectId = selectedProjectId;

            Snackbar.Add($"Default configuration saved: {processName} / {projectName}", Severity.Success);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving default configuration");
            Snackbar.Add("Error saving default configuration", Severity.Error);
        }
    }

    private string GetProcessName(string processId)
    {
        if (string.IsNullOrEmpty(processId)) return "Unknown Process";
        var process = availableProcesses?.FirstOrDefault(p => p.Id.ToString() == processId);
        return process?.Name ?? "Unknown Process";
    }

    private async Task LoadWorkItemHierarchyAsync()
    {
        try
        {
            var hierarchyKey = $"work-item-hierarchy-{selectedProcessId}";
            var hierarchyJson = await SettingsRepository.GetOrCreateAsync(hierarchyKey, "[]");

            // Try to load using the new format first
            var hierarchyLevels = WorkItemHelper.ParseHierarchyLevelsJson(hierarchyJson);
            
            if (hierarchyLevels != null && availableWorkItemTypes != null)
            {
                workItemHierarchy.Clear();
                hierarchyAudiences.Clear();

                foreach (var level in hierarchyLevels)
                {
                    var levelItems = new List<WorkItemTypeSummary>();
                    foreach (var workItemName in level.WorkItemTypes)
                    {
                        var workItem = availableWorkItemTypes.FirstOrDefault(w => w.Name == workItemName);
                        if (workItem != null)
                        {
                            levelItems.Add(workItem);
                        }
                    }
                    
                    if (levelItems.Any())
                    {
                        workItemHierarchy.Add(levelItems);
                        hierarchyAudiences.Add(level.Audience?.ToList() ?? new List<string>());
                    }
                }
            }

            UpdateUnassignedWorkItems();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading work item hierarchy");
        }
    }

    private async Task SaveHierarchyAsync()
    {
        try
        {
            var selectedProcess = availableProcesses?.FirstOrDefault(p => p.Id.ToString() == selectedProcessId);
            var processName = selectedProcess?.Name ?? "Unknown Process";

            var hierarchyKey = $"work-item-hierarchy-{selectedProcessId}";
            
            // Create hierarchy levels with audiences
            var hierarchyLevels = new List<HierarchyLevel>();
            for (int i = 0; i < workItemHierarchy.Count; i++)
            {
                var level = workItemHierarchy[i];
                var audiences = i < hierarchyAudiences.Count ? hierarchyAudiences[i] : new List<string>();
                
                hierarchyLevels.Add(new HierarchyLevel
                {
                    WorkItemTypes = level.Select(wi => wi.Name).ToList(),
                    Audience = audiences
                });
            }

            var hierarchyJson = WorkItemHelper.SerializeHierarchyLevels(hierarchyLevels);

            await SettingsRepository.SetAsync(hierarchyKey, hierarchyJson, $"Process: {processName}");
            hasHierarchyChanges = false;

            Snackbar.Add("Work item hierarchy saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving work item hierarchy");
            Snackbar.Add("Error saving work item hierarchy", Severity.Error);
        }
    }

    private void UpdateUnassignedWorkItems()
    {
        if (availableWorkItemTypes == null)
        {
            unassignedWorkItems = null;
            return;
        }

        var assignedWorkItems = workItemHierarchy.SelectMany(level => level).ToHashSet();
        unassignedWorkItems = availableWorkItemTypes.Where(wi => !assignedWorkItems.Contains(wi)).ToList();
        
        if (unassignedWorkItems.Any() && workItemHierarchy.Count == 0)
        {
            workItemHierarchy.Add(new List<WorkItemTypeSummary>());
            hierarchyAudiences.Add(new List<string>());
            hasHierarchyChanges = true;
        }
    }

    private void AddToHierarchy(WorkItemTypeSummary workItem)
    {
        if (workItemHierarchy.Count == 0)
        {
            workItemHierarchy.Add(new List<WorkItemTypeSummary>());
            hierarchyAudiences.Add(new List<string>());
        }

        workItemHierarchy[0].Add(workItem);
        UpdateUnassignedWorkItems();
        hasHierarchyChanges = true;
        StateHasChanged();
    }

    private void RemoveFromHierarchy(WorkItemTypeSummary workItem, int level)
    {
        if (level < workItemHierarchy.Count)
        {
            workItemHierarchy[level].Remove(workItem);

            if (!workItemHierarchy[level].Any())
            {
                workItemHierarchy.RemoveAt(level);
                if (level < hierarchyAudiences.Count)
                    hierarchyAudiences.RemoveAt(level);
            }

            UpdateUnassignedWorkItems();
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private int GetLevelForItem(WorkItemTypeSummary item)
    {
        for (int i = 0; i < workItemHierarchy.Count; i++)
        {
            if (workItemHierarchy[i].Contains(item))
                return i;
        }
        return -1;
    }

    private void AddLevelAbove(int level)
    {
        if (level >= 0 && level <= workItemHierarchy.Count)
        {
            workItemHierarchy.Insert(level, new List<WorkItemTypeSummary>());
            hierarchyAudiences.Insert(level, new List<string>());
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void AddLevelBelow(int level)
    {
        if (level >= 0 && level < workItemHierarchy.Count)
        {
            workItemHierarchy.Insert(level + 1, new List<WorkItemTypeSummary>());
            hierarchyAudiences.Insert(level + 1, new List<string>());
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void RemoveLevel(int level)
    {
        if (level < workItemHierarchy.Count && workItemHierarchy.Count > 1)
        {
            workItemHierarchy.RemoveAt(level);
            if (level < hierarchyAudiences.Count)
                hierarchyAudiences.RemoveAt(level);
            UpdateUnassignedWorkItems();
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void MoveLevelUp(int level)
    {
        if (level > 0 && level < workItemHierarchy.Count)
        {
            (workItemHierarchy[level], workItemHierarchy[level - 1]) = (workItemHierarchy[level - 1], workItemHierarchy[level]);
            if (level < hierarchyAudiences.Count && (level - 1) < hierarchyAudiences.Count)
                (hierarchyAudiences[level], hierarchyAudiences[level - 1]) = (hierarchyAudiences[level - 1], hierarchyAudiences[level]);
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void MoveLevelDown(int level)
    {
        if (level >= 0 && level < workItemHierarchy.Count - 1)
        {
            (workItemHierarchy[level], workItemHierarchy[level + 1]) = (workItemHierarchy[level + 1], workItemHierarchy[level]);
            if (level < hierarchyAudiences.Count && (level + 1) < hierarchyAudiences.Count)
                (hierarchyAudiences[level], hierarchyAudiences[level + 1]) = (hierarchyAudiences[level + 1], hierarchyAudiences[level]);
            hasHierarchyChanges = true;
            StateHasChanged();
        }
    }

    private void ClearHierarchy()
    {
        workItemHierarchy.Clear();
        hierarchyAudiences.Clear();
        workItemHierarchy.Add(new List<WorkItemTypeSummary>());
        hierarchyAudiences.Add(new List<string>());
        UpdateUnassignedWorkItems();
        hasHierarchyChanges = true;
        StateHasChanged();
    }

    private void OnItemDropped(MudItemDropInfo<WorkItemTypeSummary> dropItem)
    {
        if (dropItem.Item == null) return;

        foreach (var level in workItemHierarchy)
            level.Remove(dropItem.Item);

        if (dropItem.DropzoneIdentifier.StartsWith("level-"))
        {
            var targetLevel = int.Parse(dropItem.DropzoneIdentifier.Replace("level-", ""));

            while (workItemHierarchy.Count <= targetLevel)
            {
                workItemHierarchy.Add(new List<WorkItemTypeSummary>());
                hierarchyAudiences.Add(new List<string>());
            }

            workItemHierarchy[targetLevel].Add(dropItem.Item);
        }

        UpdateUnassignedWorkItems();
        hasHierarchyChanges = true;
        StateHasChanged();
    }

    private bool GetItemsForDropzone(WorkItemTypeSummary item, string dropzone)
    {
        if (dropzone == "unassigned")
            return unassignedWorkItems?.Contains(item) ?? false;

        if (dropzone.StartsWith("level-"))
        {
            var level = int.Parse(dropzone.Replace("level-", ""));
            return level < workItemHierarchy.Count && workItemHierarchy[level].Contains(item);
        }

        return false;
    }

    private string GetWorkItemChipStyle(WorkItemTypeSummary workItem, bool inHierarchy)
    {
        var baseColor = !string.IsNullOrEmpty(workItem.Color) ? workItem.Color : "#1976d2";

        if (inHierarchy)
            return $"background-color: {baseColor}; color: white; margin: 4px; border: 2px solid rgba(255,255,255,0.3); box-shadow: 0 2px 4px rgba(0,0,0,0.2); border-radius: 8px; min-width: 150px; max-width: 200px;";
        else
            return $"background-color: {baseColor}; color: white; margin: 4px; opacity: 0.9; transition: all 0.2s ease-in-out; border-radius: 8px; min-width: 150px; max-width: 200px;";
    }

    // Audience checkbox methods
    private bool IsAudienceSelected(int level, string audience)
    {
        if (level >= hierarchyAudiences.Count) return false;
        return hierarchyAudiences[level].Contains(audience);
    }

    private void OnAudienceChanged(int level, string audience, bool isSelected)
    {
        // Ensure we have enough audience lists
        while (hierarchyAudiences.Count <= level)
            hierarchyAudiences.Add(new List<string>());

        var levelAudiences = hierarchyAudiences[level];
        
        if (isSelected && !levelAudiences.Contains(audience))
        {
            levelAudiences.Add(audience);
            hasHierarchyChanges = true;
        }
        else if (!isSelected && levelAudiences.Contains(audience))
        {
            levelAudiences.Remove(audience);
            hasHierarchyChanges = true;
        }

        StateHasChanged();
    }
}