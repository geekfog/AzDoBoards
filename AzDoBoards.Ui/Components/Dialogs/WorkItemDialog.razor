@using AzDoBoards.Client.Models
@using AzDoBoards.Client.Services
@using AzDoBoards.Client
@using AzDoBoards.Utility
@using MudBlazor
@inject IServiceProvider ServiceProvider
@inject ISnackbar Snackbar
@inject ILogger<WorkItemDialog> Logger

<MudDialog>
    <DialogContent>
        @if (isLoading)
        {
            <MudStack Row AlignItems="AlignItems.Center" Class="my-4">
                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                <MudText Typo="Typo.body2" Class="ml-2">Loading work item...</MudText>
            </MudStack>
        }
        else if (!string.IsNullOrEmpty(errorMessage))
        {
            <MudAlert Severity="Severity.Error" Class="my-4">
                @errorMessage
            </MudAlert>
        }
        else if (workItem != null && workItemLayout != null)
        {
            <MudStack Spacing="3">
                <!-- Work Item Header -->
                <MudPaper Class="pa-3" Elevation="0" Style="background-color: var(--mud-palette-background-grey);">
                    <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                        <MudIcon Icon="@WorkItemHelper.GetWorkItemTypeSvgIcon(workItem.WorkItemType)" Size="Size.Medium" />
                        <MudStack Spacing="0">
                            <MudText Typo="Typo.h6">@workItem.WorkItemType @workItem.Id</MudText>
                            <MudText Typo="Typo.body2" Color="Color.Secondary">@workItem.WorkItemType in @ProjectName</MudText>
                        </MudStack>
                    </MudStack>
                </MudPaper>

                <MudDivider />

                <!-- Dynamic Field Groups from Layout -->
                @foreach (var group in workItemLayout.Groups.Where(g => g.IsVisible && g.Fields.Any(f => !f.IsReadOnly || ShouldShowReadOnlyField(f))))
                {
                    <MudText Typo="Typo.h6" Class="mt-3">@group.Label</MudText>
                    <MudGrid>
                        @foreach (var field in group.Fields.Where(f => !f.IsReadOnly || ShouldShowReadOnlyField(f)))
                        {
                            <MudItem xs="12" md="@(IsFullWidthField(field) ? 12 : 6)">
                                @RenderField(field)
                            </MudItem>
                        }
                    </MudGrid>
                }

                @if (hasChanges)
                {
                    <MudAlert Severity="Severity.Info" Dense="true">
                        You have unsaved changes
                    </MudAlert>
                }
            </MudStack>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel" Disabled="isLoading || isSaving">Cancel</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="SaveAsync" Disabled="isLoading || isSaving || !hasChanges || HasValidationErrors()">
            @if (isSaving)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <span>Saving...</span>
            }
            else
            {
                <span>Save</span>
            }
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] private MudBlazor.IDialogReference MudDialog { get; set; }

    [Parameter] public int WorkItemId { get; set; }
    [Parameter] public string ProcessId { get; set; } = string.Empty;
    [Parameter] public string ProjectId { get; set; } = string.Empty;
    [Parameter] public string ProjectName { get; set; } = string.Empty;

    private bool isLoading = true;
    private bool isSaving = false;
    private string errorMessage = string.Empty;
    private WorkItem? workItem;
    private WorkItemTypeLayout? workItemLayout;

    // Dynamic field values storage
    private Dictionary<string, string> editedValues = new();
    private Dictionary<string, string> originalValues = new();

    private bool hasChanges => !editedValues.SequenceEqual(originalValues);

    // Core fields that should be shown even if read-only
    private static readonly HashSet<string> ImportantReadOnlyFields = new(StringComparer.OrdinalIgnoreCase)
    {
        "System.CreatedDate",
        "System.CreatedBy",
        "System.ChangedDate",
        "System.ChangedBy"
    };

    // Fields that should be full width
    private static readonly HashSet<string> FullWidthFields = new(StringComparer.OrdinalIgnoreCase)
    {
        "System.Title",
        "System.Description",
        "System.Tags",
        "Microsoft.VSTS.Common.AcceptanceCriteria"
    };

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkItemAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && MudDialog != null)
        {      
            Logger.LogInformation(MudDialog.Id.ToString());
        }
    }

    private async Task LoadWorkItemAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = string.Empty;
            StateHasChanged();

            var workItemService = ServiceProvider.GetRequiredService<WorkItemServices>();
            
            // Load the work item
            var filter = new WorkItemFilter
            {
                ProjectId = ProjectId,
                Top = 1
            };
            
            var workItems = await workItemService.GetWorkItemsAsync(filter);
            workItem = workItems.FirstOrDefault(wi => wi.Id == WorkItemId);

            if (workItem == null)
            {
                errorMessage = $"Work item {WorkItemId} not found.";
                return;
            }

            // Load work item type layout and field definitions
            if (!string.IsNullOrEmpty(ProcessId) && Guid.TryParse(ProcessId, out var processGuid))
            {
                var processService = ServiceProvider.GetRequiredService<ProcessServices>();
                workItemLayout = await processService.GetWorkItemTypeLayoutAsync(processGuid, workItem.WorkItemType);
            }

            // Initialize edited values from work item
            InitializeEditedValues();
            
            Logger.LogInformation("Loaded work item {WorkItemId} with {FieldCount} fields for editing", 
                WorkItemId, workItemLayout?.AllFields.Count ?? 0);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading work item {WorkItemId}", WorkItemId);
            errorMessage = $"Error loading work item: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private void InitializeEditedValues()
    {
        if (workItem == null || workItemLayout == null) return;

        originalValues.Clear();
        editedValues.Clear();

        foreach (var field in workItemLayout.AllFields.Where(f => !f.IsReadOnly))
        {
            var value = GetFieldValueAsString(field.ReferenceName);
            originalValues[field.ReferenceName] = value;
            editedValues[field.ReferenceName] = value;
        }
    }

    private string GetFieldValueAsString(string fieldReferenceName)
    {
        if (workItem == null) return string.Empty;

        // Handle special core fields
        if (fieldReferenceName == "System.Title")
            return workItem.Title;

        if (fieldReferenceName == "System.State")
            return workItem.State;

        if (fieldReferenceName == "System.AssignedTo")
            return workItem.AssignedToDisplayName;

        if (fieldReferenceName == "Microsoft.VSTS.Scheduling.TargetDate" && workItem.TargetDate.HasValue)
            return workItem.TargetDate.Value.ToString("yyyy-MM-dd");

        if (fieldReferenceName == "System.Tags")
            return string.Join("; ", workItem.Tags);

        // Try to get from Fields dictionary
        if (workItem.Fields.TryGetValue(fieldReferenceName, out var value))
        {
            if (value is DateTime dateValue)
                return dateValue.ToString("yyyy-MM-dd");
            
            if (value is bool boolValue)
                return boolValue.ToString();

            return value?.ToString() ?? string.Empty;
        }

        return string.Empty;
    }

    private bool ShouldShowReadOnlyField(WorkItemFieldDefinition field)
    {
        return ImportantReadOnlyFields.Contains(field.ReferenceName);
    }

    private bool IsFullWidthField(WorkItemFieldDefinition field)
    {
        return FullWidthFields.Contains(field.ReferenceName) || 
               field.FieldType.Equals("Html", StringComparison.OrdinalIgnoreCase);
    }

    private bool HasValidationErrors()
    {
        if (workItemLayout == null) return false;

        foreach (var field in workItemLayout.AllFields.Where(f => f.IsRequired && !f.IsReadOnly))
        {
            if (editedValues.TryGetValue(field.ReferenceName, out var value) && string.IsNullOrWhiteSpace(value))
            {
                return true;
            }
        }

        return false;
    }

    private RenderFragment RenderField(WorkItemFieldDefinition field) => __builder =>
    {
        if (!editedValues.ContainsKey(field.ReferenceName))
        {
            editedValues[field.ReferenceName] = string.Empty;
        }

        // Read-only fields
        if (field.IsReadOnly)
        {
            <MudTextField Value="@GetFieldValueAsString(field.ReferenceName)"
                          Label="@field.Name"
                          Variant="Variant.Outlined"
                          ReadOnly="true"
                          Disabled="true"
                          HelperText="@(field.HelpText ?? "Read-only field")" />
            return;
        }

        // Determine field type and render appropriate control
        switch (field.FieldType.ToLowerInvariant())
        {
            case "string":
            case "plaintext":
                if (field.AllowedValues.Any())
                {
                    // Dropdown for fields with allowed values
                    <MudSelect T="string" 
                               @bind-Value="editedValues[field.ReferenceName]"
                               Label="@field.Name"
                               Variant="Variant.Outlined"
                               Required="@field.IsRequired"
                               HelperText="@field.HelpText">
                        @foreach (var allowedValue in field.AllowedValues)
                        {
                            <MudSelectItem T="string" Value="@allowedValue">@allowedValue</MudSelectItem>
                        }
                    </MudSelect>
                }
                else if (field.ReferenceName == "System.Tags")
                {
                    <MudTextField @bind-Value="editedValues[field.ReferenceName]"
                                  Label="@field.Name"
                                  Variant="Variant.Outlined"
                                  Required="@field.IsRequired"
                                  HelperText="@(field.HelpText ?? "Separate tags with semicolons")" />
                }
                else
                {
                    <MudTextField @bind-Value="editedValues[field.ReferenceName]"
                                  Label="@field.Name"
                                  Variant="Variant.Outlined"
                                  Required="@field.IsRequired"
                                  HelperText="@field.HelpText" />
                }
                break;

            case "html":
                <MudTextField @bind-Value="editedValues[field.ReferenceName]"
                              Label="@field.Name"
                              Variant="Variant.Outlined"
                              Lines="5"
                              Required="@field.IsRequired"
                              HelperText="@(field.HelpText ?? "HTML content")" />
                break;

            case "datetime":
                DateTime? dateValue = null;
                if (!string.IsNullOrEmpty(editedValues[field.ReferenceName]) && 
                    DateTime.TryParse(editedValues[field.ReferenceName], out var parsedDate))
                {
                    dateValue = parsedDate;
                }
                <MudDatePicker Label="@field.Name"
                               Date="@dateValue"
                               DateChanged="@((DateTime? d) => editedValues[field.ReferenceName] = d?.ToString("yyyy-MM-dd") ?? string.Empty)"
                               Variant="Variant.Outlined"
                               Clearable="!field.IsRequired"
                               Required="@field.IsRequired"
                               HelperText="@field.HelpText" />
                break;

            case "integer":
                <MudNumericField @bind-Value="editedValues[field.ReferenceName]"
                                 Label="@field.Name"
                                 Variant="Variant.Outlined"
                                 Required="@field.IsRequired"
                                 HelperText="@field.HelpText" />
                break;

            case "double":
                <MudNumericField @bind-Value="editedValues[field.ReferenceName]"
                                 Label="@field.Name"
                                 Variant="Variant.Outlined"
                                 Required="@field.IsRequired"
                                 HelperText="@field.HelpText" />
                break;

            case "boolean":
                bool boolValue = bool.TryParse(editedValues[field.ReferenceName], out var parsed) && parsed;
                <MudSwitch Value="@boolValue"
                           ValueChanged="@((bool v) => { editedValues[field.ReferenceName] = v.ToString(); StateHasChanged(); })"
                           Label="@field.Name"
                           Color="Color.Primary">
                </MudSwitch>
                @if (!string.IsNullOrEmpty(field.HelpText))
                {
                    <MudText Typo="Typo.caption" Class="ml-2">@field.HelpText</MudText>
                }
                break;

            case "treepath":
            case "identity":
            default:
                <MudTextField @bind-Value="editedValues[field.ReferenceName]"
                              Label="@field.Name"
                              Variant="Variant.Outlined"
                              Required="@field.IsRequired"
                              HelperText="@(field.HelpText ?? field.FieldType)" />
                break;
        }
    };

    private async Task SaveAsync()
    {
        if (workItem == null || workItemLayout == null || !hasChanges)
        {
            MudDialog.Close(DialogResult.Ok(false));
            return;
        }

        try
        {
            isSaving = true;
            StateHasChanged();

            var patchDocument = new Microsoft.VisualStudio.Services.WebApi.Patch.Json.JsonPatchDocument();

            // Build patch document for all changed fields
            foreach (var field in workItemLayout.AllFields.Where(f => !f.IsReadOnly))
            {
                if (editedValues.TryGetValue(field.ReferenceName, out var newValue) &&
                    originalValues.TryGetValue(field.ReferenceName, out var oldValue) &&
                    newValue != oldValue)
                {
                    object? patchValue = newValue;

                    // Convert value based on field type
                    switch (field.FieldType.ToLowerInvariant())
                    {
                        case "datetime":
                            if (!string.IsNullOrEmpty(newValue) && DateTime.TryParse(newValue, out var dateValue))
                            {
                                patchValue = dateValue.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
                            }
                            else if (string.IsNullOrEmpty(newValue))
                            {
                                // Remove the field
                                patchDocument.Add(new Microsoft.VisualStudio.Services.WebApi.Patch.Json.JsonPatchOperation
                                {
                                    Operation = Microsoft.VisualStudio.Services.WebApi.Patch.Operation.Remove,
                                    Path = $"/fields/{field.ReferenceName}"
                                });
                                continue;
                            }
                            break;

                        case "integer":
                            if (!string.IsNullOrEmpty(newValue) && int.TryParse(newValue, out var intValue))
                            {
                                patchValue = intValue;
                            }
                            break;

                        case "double":
                            if (!string.IsNullOrEmpty(newValue) && double.TryParse(newValue, out var doubleValue))
                            {
                                patchValue = doubleValue;
                            }
                            break;

                        case "boolean":
                            if (bool.TryParse(newValue, out var boolValue))
                            {
                                patchValue = boolValue;
                            }
                            break;
                    }

                    patchDocument.Add(new Microsoft.VisualStudio.Services.WebApi.Patch.Json.JsonPatchOperation
                    {
                        Operation = Microsoft.VisualStudio.Services.WebApi.Patch.Operation.Add,
                        Path = $"/fields/{field.ReferenceName}",
                        Value = patchValue
                    });
                }
            }

            if (patchDocument.Count == 0)
            {
                Logger.LogInformation("No changes detected for work item {WorkItemId}", WorkItemId);
                MudDialog.Close(DialogResult.Ok(false));
                return;
            }

            Logger.LogInformation("Updating work item {WorkItemId} with {ChangeCount} field changes", 
                WorkItemId, patchDocument.Count);

            // Update the work item
            var connection = await ServiceProvider.GetRequiredService<ConnectionFactory>().GetConnectionAsync();
            var workItemClient = connection.GetClient<Microsoft.TeamFoundation.WorkItemTracking.WebApi.WorkItemTrackingHttpClient>();
            var updatedWorkItem = await workItemClient.UpdateWorkItemAsync(patchDocument, WorkItemId);

            if (updatedWorkItem != null)
            {
                Logger.LogInformation("Successfully updated work item {WorkItemId}", WorkItemId);
                Snackbar.Add($"Work item {WorkItemId} updated successfully ({patchDocument.Count} fields changed)", Severity.Success);
                MudDialog.Close(DialogResult.Ok(true));
            }
            else
            {
                errorMessage = "Failed to update work item";
                Logger.LogError("Failed to update work item {WorkItemId}", WorkItemId);
                Snackbar.Add($"Failed to update work item {WorkItemId}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving work item {WorkItemId}", WorkItemId);
            errorMessage = $"Error saving work item: {ex.Message}";
            Snackbar.Add($"Error saving work item: {ex.Message}", Severity.Error);
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    private void Cancel()
    {
        MudDialog.Close(DialogResult.Cancel());
    }
}

